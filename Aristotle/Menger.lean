/-
This file was generated by Aristotle.
This project request had uuid: 3f0889a6-97fb-4dc9-b7e3-7271a320cd49
This project request had uuid: 7b68ab0a-0995-4676-996d-1d38e53d9b5a
This project request had uuid: 92285974-ca7c-4130-b513-da721c60ddd6
This project request had uuid: c9aae1d4-2808-455a-990f-7958bf3f6d20
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A set of vertices S separates A from B in G if every A-B path in G contains a vertex from S.
-/
def SimpleGraph.Separates {V : Type*} (G : SimpleGraph V) (A B : Set V) (S : Finset V) : Prop :=
  ∀ u ∈ A, ∀ v ∈ B, ∀ p : G.Walk u v, p.IsPath → ∃ x ∈ p.support, x ∈ S

/-
An A-B path is a path in G starting in A and ending in B.
-/
structure SimpleGraph.ABPath {V : Type*} (G : SimpleGraph V) (A B : Set V) where
  u : V
  v : V
  walk : G.Walk u v
  is_path : walk.IsPath
  start_in_A : u ∈ A
  end_in_B : v ∈ B

/-
A set of A-B paths is disjoint if any two distinct paths in the set are vertex-disjoint.
-/
def SimpleGraph.DisjointPaths {V : Type*} [DecidableEq V] (G : SimpleGraph V) (A B : Set V) (P : Finset (G.ABPath A B)) : Prop :=
  ∀ p ∈ P, ∀ q ∈ P, p ≠ q → Disjoint p.walk.support.toFinset q.walk.support.toFinset

/-
The set of A-B paths is finite.
-/
instance SimpleGraph.ABPath.instFinite {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) : Finite (G.ABPath A B) := by
  -- Since the vertex set is finite, the set of all possible paths between any two vertices is also finite. We can use the fact that the set of all paths between any two vertices is finite.
  have h_finite_paths : ∀ u v : V, Set.Finite {p : G.Walk u v | p.IsPath} := by
    intro u v
    have h_finite_walks : Set.Finite {p : G.Walk u v | p.length ≤ Fintype.card V} := by
      have h_finite_walks : ∀ n : ℕ, Set.Finite {p : G.Walk u v | p.length = n} := by
        sorry
      exact Set.Finite.subset ( Set.Finite.biUnion ( Set.finite_Iic ( Fintype.card V ) ) fun n hn => h_finite_walks n ) fun p hp => by aesop;
    refine' h_finite_walks.subset fun p hp => _;
    have := hp.length_lt;
    exact le_of_lt this;
  -- Since A and B are finite, the set of pairs (u, v) where u is in A and v is in B is also finite.
  have h_finite_pairs : Set.Finite {p : V × V | p.1 ∈ A ∧ p.2 ∈ B} := by
    exact Set.toFinite _;
  have h_finite_paths : Set.Finite {p : Σ u : V, Σ v : V, G.Walk u v | p.1 ∈ A ∧ p.2.1 ∈ B ∧ p.2.2.IsPath} := by
    have h_finite_paths : Set.Finite (⋃ p ∈ {p : V × V | p.1 ∈ A ∧ p.2 ∈ B}, {q : Σ u : V, Σ v : V, G.Walk u v | q.1 = p.1 ∧ q.2.1 = p.2 ∧ q.2.2.IsPath}) := by
      refine' Set.Finite.biUnion h_finite_pairs fun p hp => _;
      exact Set.Finite.subset ( Set.Finite.image ( fun q : G.Walk p.1 p.2 => ⟨ p.1, p.2, q ⟩ ) ( h_finite_paths p.1 p.2 ) ) fun q hq => by aesop;
    exact h_finite_paths.subset fun p hp => by aesop;
  convert h_finite_paths.of_injective _ _;
  exact fun p => ⟨ ⟨ p.u, p.v, p.walk ⟩, p.start_in_A, p.end_in_B, p.is_path ⟩;
  intro p q h; cases p; cases q; aesop;

noncomputable instance SimpleGraph.ABPath.instFintype {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) : Fintype (G.ABPath A B) := Fintype.ofFinite _

/-
The set of all vertex sets that separate A from B.
-/
def SimpleGraph.separators {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) : Finset (Finset V) :=
  (Finset.powerset Finset.univ).filter (fun S => G.Separates A B S)

/-
The set of all sets of disjoint A-B paths.
-/
noncomputable def SimpleGraph.disjoint_path_sets {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) : Finset (Finset (G.ABPath A B)) :=
  (Finset.powerset Finset.univ).filter (fun P => G.DisjointPaths A B P)

/-
The set of separators is nonempty (e.g., the set of all vertices is a separator).
-/
lemma SimpleGraph.separators_nonempty {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) :
  (G.separators A B).Nonempty := by
    refine' ⟨ Finset.univ, _ ⟩;
    -- Since the universal set contains all vertices, any path between A and B must pass through some vertex in the universal set.
    simp [SimpleGraph.separators];
    exact fun u hu v hv p hp => ⟨ u, p.start_mem_support, Finset.mem_univ _ ⟩

/-
The set of disjoint path sets is nonempty (the empty set is a valid set of disjoint paths).
-/
lemma SimpleGraph.disjoint_path_sets_nonempty {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) :
  (G.disjoint_path_sets A B).Nonempty := by
  use ∅
  simp [disjoint_path_sets, DisjointPaths]

/-
The minimum size of a separator and the maximum number of disjoint paths.
-/
noncomputable def SimpleGraph.min_separator_size {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) : ℕ :=
  ((G.separators A B).image Finset.card).min' ((G.separators_nonempty A B).image Finset.card)

noncomputable def SimpleGraph.max_disjoint_paths_size {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) : ℕ :=
  ((G.disjoint_path_sets A B).image Finset.card).max' ((G.disjoint_path_sets_nonempty A B).image Finset.card)

/-
The maximum number of disjoint A-B paths is at most the minimum size of an A-B separator.
-/
theorem SimpleGraph.Menger_weak {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) :
  G.max_disjoint_paths_size A B ≤ G.min_separator_size A B := by
    by_contra h_contra;
    -- Let $\mathcal{P}$ be a set of $m$ disjoint A-B paths.
    obtain ⟨P, hP⟩ : ∃ P : Finset (G.ABPath A B), G.DisjointPaths A B P ∧ P.card > G.min_separator_size A B := by
      simp_all +decide [ SimpleGraph.max_disjoint_paths_size ];
      unfold SimpleGraph.disjoint_path_sets at h_contra; aesop;
    -- Let $S$ be an A-B separator of size $k$.
    obtain ⟨S, hS⟩ : ∃ S : Finset V, G.Separates A B S ∧ S.card = G.min_separator_size A B := by
      have := Finset.min'_mem ( ( G.separators A B ).image Finset.card ) ⟨ _, Finset.mem_image_of_mem _ ( Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( Finset.subset_univ ( Finset.univ : Finset V ) ), ( Finset.mem_filter.mp ( Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( Finset.subset_univ ( Finset.univ : Finset V ) ), ( fun u hu v hv p hp ↦ by
        cases p <;> aesop ) ⟩ ) |>.2 ) ⟩ ) ⟩
      generalize_proofs at *;
      rw [ Finset.mem_image ] at this; obtain ⟨ S, hS₁, hS₂ ⟩ := this; exact ⟨ S, Finset.mem_filter.mp hS₁ |>.2, hS₂ ⟩ ;
    -- Since $S$ is an A-B separator, every path in $\mathcal{P}$ must contain at least one vertex from $S$.
    have h_path_inter_S : ∀ p ∈ P, ∃ x ∈ p.walk.support, x ∈ S := by
      exact fun p hp => hS.1 p.u p.start_in_A p.v p.end_in_B p.walk p.is_path;
    have h_path_inter_S : Finset.card (Finset.biUnion P (fun p => p.walk.support.toFinset ∩ S)) ≥ P.card := by
      rw [ Finset.card_biUnion ];
      · exact Finset.card_eq_sum_ones P ▸ Finset.sum_le_sum fun p hp => Finset.card_pos.mpr ⟨ Classical.choose ( h_path_inter_S p hp ), Finset.mem_inter.mpr ⟨ by simpa using Classical.choose_spec ( h_path_inter_S p hp ) |>.1, by simpa using Classical.choose_spec ( h_path_inter_S p hp ) |>.2 ⟩ ⟩;
      · intro p hp q hq hpq; specialize hP; have := hP.1 p hp q hq hpq; simp_all +decide [ Finset.disjoint_left ] ;
    exact h_path_inter_S.not_gt ( lt_of_le_of_lt ( Finset.card_le_card ( Finset.biUnion_subset.mpr fun p hp => Finset.inter_subset_right ) ) ( by linarith ) )

/-
Base case of Menger's theorem: if G has no edges, the theorem holds.
-/
lemma SimpleGraph.Menger_strong_base {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) (h : G.edgeSet = ∅) :
  G.min_separator_size A B ≤ G.max_disjoint_paths_size A B := by
    have h_empty : ∀ u v, G.Walk u v → u = v := by
      intro u v p; induction p <;> aesop;
    unfold SimpleGraph.min_separator_size SimpleGraph.max_disjoint_paths_size;
    simp +decide [ SimpleGraph.separators, SimpleGraph.disjoint_path_sets ];
    simp +decide [ Finset.min', Finset.max', SimpleGraph.Separates ];
    refine' ⟨ Finset.filter ( fun p => p.u = p.v ∧ p.u ∈ A ∩ B ) ( Finset.univ : Finset ( G.ABPath A B ) ), _, Finset.image ( fun p => p.u ) ( Finset.filter ( fun p => p.u = p.v ∧ p.u ∈ A ∩ B ) ( Finset.univ : Finset ( G.ABPath A B ) ) ), _, _ ⟩;
    · intro p hp q hq hpq;
      cases p ; cases q ; aesop;
    · intro u hu v hv p hp;
      obtain rfl := h_empty u v p;
      exact ⟨ u, by simp, Finset.mem_image.mpr ⟨ ⟨ u, u, p, hp, hu, hv ⟩, by aesop ⟩ ⟩;
    · exact Finset.card_image_le

/-
The contraction of edge (x, y) in G.
-/
def SimpleGraph.contractEdge {V : Type*} [DecidableEq V] (G : SimpleGraph V) (x y : V) : SimpleGraph (Quotient (Setoid.mk (fun a b => a = b ∨ (a = x ∧ b = y) ∨ (a = y ∧ b = x)) (by
constructor <;> aesop
))) :=
  let s := Setoid.mk (fun a b => a = b ∨ (a = x ∧ b = y) ∨ (a = y ∧ b = x)) (by
  constructor <;> aesop
  )
  SimpleGraph.fromRel (fun a b => ∃ a' b', Quotient.mk s a' = a ∧ Quotient.mk s b' = b ∧ G.Adj a' b')

/-
Definitions for edge contraction: the setoid identifying the endpoints, the contracted graph, and the projection map.
-/
def SimpleGraph.contractEdgeSetoid {V : Type*} [DecidableEq V] (x y : V) : Setoid V :=
  Setoid.mk (fun a b => a = b ∨ (a = x ∧ b = y) ∨ (a = y ∧ b = x)) (by
  constructor <;> aesop
  )

def SimpleGraph.contractEdge' {V : Type*} [DecidableEq V] (G : SimpleGraph V) (x y : V) : SimpleGraph (Quotient (SimpleGraph.contractEdgeSetoid x y)) :=
  SimpleGraph.fromRel (fun a b => ∃ a' b', Quotient.mk (SimpleGraph.contractEdgeSetoid x y) a' = a ∧ Quotient.mk (SimpleGraph.contractEdgeSetoid x y) b' = b ∧ G.Adj a' b')

def SimpleGraph.contractEdgeProj {V : Type*} [DecidableEq V] (x y : V) : V → Quotient (SimpleGraph.contractEdgeSetoid x y) :=
  Quotient.mk (SimpleGraph.contractEdgeSetoid x y)

/-
The number of vertices in the contracted graph is strictly less than in the original graph (if x != y). Also define the image of a set under contraction.
-/
lemma SimpleGraph.contractEdge_card_lt {V : Type*} [Fintype V] [DecidableEq V] (x y : V) (h : x ≠ y) :
  Fintype.card (Quotient (SimpleGraph.contractEdgeSetoid x y)) < Fintype.card V := by
    have h_card : Fintype.card (Quotient (SimpleGraph.contractEdgeSetoid x y)) ≤ Finset.card (Finset.image (fun z => Quotient.mk (SimpleGraph.contractEdgeSetoid x y) z) (Finset.univ.erase x)) := by
      have h_card : Finset.image (fun z => Quotient.mk (SimpleGraph.contractEdgeSetoid x y) z) (Finset.univ.erase x) = Finset.univ := by
        ext z
        simp [Finset.mem_image];
        obtain ⟨ a, rfl ⟩ := Quotient.exists_rep z;
        by_cases ha : a = x;
        · exact ⟨ y, by tauto, by rw [ ha ] ; exact Quotient.sound ( by tauto ) ⟩;
        · exact ⟨ a, ha, rfl ⟩;
      rw [ h_card, Finset.card_univ ];
    grind

def SimpleGraph.contractEdge_liftSet {V : Type*} [DecidableEq V] (x y : V) (S : Set V) : Set (Quotient (SimpleGraph.contractEdgeSetoid x y)) :=
  S.image (SimpleGraph.contractEdgeProj x y)

/-
Given a walk in G, there exists a walk in the contracted graph G/e between the projected endpoints, whose support is contained in the image of the original walk's support.
-/
lemma SimpleGraph.exists_walk_of_path_contraction {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (x y : V)
  {u v : V} (p : G.Walk u v) :
  ∃ (w : (G.contractEdge' x y).Walk (SimpleGraph.contractEdgeProj x y u) (SimpleGraph.contractEdgeProj x y v)),
    w.support.toFinset ⊆ p.support.toFinset.image (SimpleGraph.contractEdgeProj x y) := by
      induction' p with u v p ih;
      · exact ⟨ SimpleGraph.Walk.nil, by simp +decide ⟩;
      · simp +zetaDelta at *;
        cases' ‹∃ w, _› with w hw;
        by_cases h : contractEdgeProj x y v = contractEdgeProj x y p;
        · grind;
        · have h_adj : (G.contractEdge' x y).Adj (contractEdgeProj x y v) (contractEdgeProj x y p) := by
            unfold SimpleGraph.contractEdge';
            aesop;
          refine' ⟨ SimpleGraph.Walk.cons h_adj w, _ ⟩;
          simp_all +decide [ Finset.subset_iff ]

/-
The preimage of a set of vertices in the contracted graph.
-/
def SimpleGraph.contractEdge_preimage {V : Type*} [Fintype V] [DecidableEq V] (x y : V) (Y : Finset (Quotient (SimpleGraph.contractEdgeSetoid x y))) : Finset V :=
  Finset.univ.filter (fun v => SimpleGraph.contractEdgeProj x y v ∈ Y)

/-
If a set of vertices separates A and B in the contracted graph G/e, then its preimage separates A and B in G.
-/
lemma SimpleGraph.contractEdge_preimage_separates {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) (x y : V)
  (Y : Finset (Quotient (SimpleGraph.contractEdgeSetoid x y)))
  (hY : (G.contractEdge' x y).Separates (SimpleGraph.contractEdge_liftSet x y A) (SimpleGraph.contractEdge_liftSet x y B) Y) :
  G.Separates A B (SimpleGraph.contractEdge_preimage x y Y) := by
    intro u hu v hv p hp;
    obtain ⟨ w, hw ⟩ := SimpleGraph.exists_walk_of_path_contraction G x y p;
    -- Since $w$ is a path in the contracted graph from $\pi(u)$ to $\pi(v)$, and $Y$ separates $\pi(A)$ and $\pi(B)$ in the contracted graph, $w$ must intersect $Y$.
    obtain ⟨ z, hzY, hzw ⟩ : ∃ z ∈ Y, z ∈ w.support := by
      specialize hY (contractEdgeProj x y u) (by
      exact Set.mem_image_of_mem _ hu) (contractEdgeProj x y v) (by
      exact Set.mem_image_of_mem _ hv) w.toPath;
      exact hY ( SimpleGraph.Walk.bypass_isPath _ ) |> fun ⟨ z, hz₁, hz₂ ⟩ => ⟨ z, hz₂, by simpa using SimpleGraph.Walk.support_bypass_subset _ hz₁ ⟩;
    have := hw ( by simpa using hzw );
    simp +zetaDelta at *;
    exact ⟨ this.choose, this.choose_spec.1, Finset.mem_filter.mpr ⟨ Finset.mem_univ _, this.choose_spec.2.symm ▸ hzY ⟩ ⟩

/-
The contracted vertex in the quotient graph.
-/
def SimpleGraph.contractEdge_vertex {V : Type*} [DecidableEq V] (x y : V) : Quotient (SimpleGraph.contractEdgeSetoid x y) :=
  Quotient.mk (SimpleGraph.contractEdgeSetoid x y) x

lemma SimpleGraph.contractEdge_vertex_eq {V : Type*} [DecidableEq V] (x y : V) :
  SimpleGraph.contractEdge_vertex x y = Quotient.mk (SimpleGraph.contractEdgeSetoid x y) y := by
  apply Quotient.sound
  right
  left
  exact ⟨rfl, rfl⟩

/-
A vertex projects to the contracted vertex if and only if it is one of the endpoints of the contracted edge.
-/
lemma SimpleGraph.contractEdgeProj_eq_vertex_iff {V : Type*} [DecidableEq V] (x y u : V) :
  SimpleGraph.contractEdgeProj x y u = SimpleGraph.contractEdgeProj x y x ↔ u = x ∨ u = y := by
    -- By definition of the projection, we have that the projection of u is equal to the projection of x if and only if u is equivalent to x under the setoid.
    simp [SimpleGraph.contractEdgeProj];
    simp [contractEdgeSetoid];
    sorry

/-
The projection map is injective on vertices that do not map to the contracted vertex.
-/
lemma SimpleGraph.contractEdgeProj_inj_on {V : Type*} [DecidableEq V] (x y : V) (u v : V)
  (hu : SimpleGraph.contractEdgeProj x y u ≠ SimpleGraph.contractEdge_vertex x y)
  (hv : SimpleGraph.contractEdgeProj x y v ≠ SimpleGraph.contractEdge_vertex x y) :
  SimpleGraph.contractEdgeProj x y u = SimpleGraph.contractEdgeProj x y v → u = v := by
    -- If the projections are equal, then u and v must be in the same equivalence class.
    intro h_eq
    have h_equiv : u = v ∨ (u = x ∧ v = y) ∨ (u = y ∧ v = x) := by
      erw [ Quotient.eq ] at h_eq ; aesop;
    tauto

/-
If the projections of two vertices are adjacent in the contracted graph and neither projects to the contracted vertex, then the original vertices are adjacent in the original graph.
-/
lemma SimpleGraph.contractEdge_adj_lift {V : Type*} [DecidableEq V] (G : SimpleGraph V) (x y : V) (u v : V)
  (hu : SimpleGraph.contractEdgeProj x y u ≠ SimpleGraph.contractEdge_vertex x y)
  (hv : SimpleGraph.contractEdgeProj x y v ≠ SimpleGraph.contractEdge_vertex x y) :
  (G.contractEdge' x y).Adj (SimpleGraph.contractEdgeProj x y u) (SimpleGraph.contractEdgeProj x y v) → G.Adj u v := by
    rintro ⟨ a, b, ha, hb, hab ⟩;
    · unfold SimpleGraph.contractEdgeProj at *;
      unfold contractEdge_vertex at *; simp_all +decide [ Quotient.eq ] ;
      unfold contractEdgeSetoid at *; aesop;
    · -- Apply the lemma that states if the projections of two vertices are adjacent and neither is the contracted vertex, then the original vertices are adjacent.
      have h_adj : contractEdgeProj x y v ≠ contractEdge_vertex x y → contractEdgeProj x y u ≠ contractEdge_vertex x y → (G.contractEdge' x y).Adj (contractEdgeProj x y v) (contractEdgeProj x y u) → G.Adj v u := by
        unfold SimpleGraph.contractEdgeProj at *;
        unfold SimpleGraph.contractEdge_vertex at *; simp_all +decide [ Quotient.eq ] ;
        unfold contractEdgeSetoid at *; aesop;
      simp_all +decide [ SimpleGraph.adj_comm ];
      unfold SimpleGraph.contractEdge' at *; aesop;

/-
The size of the preimage of a set of vertices in the contracted graph.
-/
lemma SimpleGraph.card_preimage_contractEdge {V : Type*} [Fintype V] [DecidableEq V] (x y : V) (h : x ≠ y)
  (Y : Finset (Quotient (SimpleGraph.contractEdgeSetoid x y))) :
  (SimpleGraph.contractEdge_preimage x y Y).card = if SimpleGraph.contractEdge_vertex x y ∈ Y then Y.card + 1 else Y.card := by
    unfold contractEdge_preimage;
    -- Let's count the number of elements in the preimage of Y.
    have h_card_preimage : (Finset.univ.filter (fun v => SimpleGraph.contractEdgeProj x y v ∈ Y)).card = ∑ z ∈ Y, (Finset.univ.filter (fun v => SimpleGraph.contractEdgeProj x y v = z)).card := by
      simp +decide only [Finset.card_filter];
      rw [ Finset.sum_comm, Finset.sum_congr rfl ] ; aesop;
    -- Let's count the number of elements in each fiber of the projection map.
    have h_fiber_card : ∀ z ∈ Y, (Finset.univ.filter (fun v => SimpleGraph.contractEdgeProj x y v = z)).card = if z = SimpleGraph.contractEdge_vertex x y then 2 else 1 := by
      intro z hz
      by_cases hz_eq : z = SimpleGraph.contractEdge_vertex x y;
      · simp [hz_eq];
        rw [ Finset.card_eq_two ];
        refine' ⟨ x, y, h, _ ⟩;
        ext v; simp [contractEdgeProj, contractEdge_vertex];
        -- exact ⟨ fun h => by cases h <;> tauto, fun h => by cases h <;> tauto ⟩;
        sorry
      · obtain ⟨ v, rfl ⟩ := Quotient.exists_rep z;
        simp +decide [ SimpleGraph.contractEdgeProj, SimpleGraph.contractEdge_vertex ];
        split_ifs with h;
        · -- exact False.elim ( hz_eq ( Quotient.sound h ) );
          sorry
        · rw [ Finset.card_eq_one ];
          use v; ext; simp [contractEdgeSetoid];
          unfold contractEdgeSetoid at h; sorry
    split_ifs <;> simp_all +decide [ Finset.sum_ite ];
    · simp_all +decide [ Finset.filter_eq', Finset.filter_ne' ];
      linarith [ Nat.sub_add_cancel ( show 1 ≤ Y.card from Finset.card_pos.mpr ⟨ _, ‹_› ⟩ ) ];
    · simp_all +decide [ Finset.filter_eq', Finset.filter_ne' ]

/-
A walk in the contracted graph that avoids the contracted vertex can be lifted to a walk in the original graph.
-/
lemma SimpleGraph.lift_walk_avoiding_contraction {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (x y : V)
  {u v : Quotient (SimpleGraph.contractEdgeSetoid x y)} (p : (G.contractEdge' x y).Walk u v)
  (hp : SimpleGraph.contractEdge_vertex x y ∉ p.support) :
  ∃ (u' v' : V) (q : G.Walk u' v'),
    SimpleGraph.contractEdgeProj x y u' = u ∧
    SimpleGraph.contractEdgeProj x y v' = v ∧
    (q.support.toFinset.image (SimpleGraph.contractEdgeProj x y)) = p.support.toFinset ∧
    x ∉ q.support ∧ y ∉ q.support := by
      induction' p with u v p ih;
      · obtain ⟨ u', rfl ⟩ := Quotient.exists_rep u;
        by_cases hu : u' = x ∨ u' = y;
        · cases hu <;> simp_all +decide [ contractEdge_vertex ];
          exact False.elim ( hp ( by sorry ) );
        · refine' ⟨ u', u', SimpleGraph.Walk.nil, _, _, _, _ ⟩ <;> simp_all +decide [ SimpleGraph.contractEdgeProj ];
          tauto;
      · rename_i h₁ h₂;
        -- Since v is not the contracted vertex, there exists a unique u' in V such that contractEdgeProj x y u' = v.
        obtain ⟨u', hu'⟩ : ∃ u' : V, contractEdgeProj x y u' = v ∧ u' ≠ x ∧ u' ≠ y := by
          rcases Quotient.exists_rep v with ⟨ u', rfl ⟩;
          refine' ⟨ u', rfl, _, _ ⟩ <;> contrapose! hp <;> simp_all +decide [ contractEdge_vertex ];
          exact Or.inl ( by sorry );
        obtain ⟨ v', hv' ⟩ := h₂ ( by intro h; simp_all +decide [ SimpleGraph.Walk.support_cons ] );
        obtain ⟨ v'', q, hv'', hv''', hq, hx, hy ⟩ := hv';
        refine' ⟨ u', v'', SimpleGraph.Walk.cons _ q, hu'.1, hv''', _, _, _ ⟩ <;> simp_all +decide [ SimpleGraph.Walk.support_cons ];
        · have h_adj : (G.contractEdge' x y).Adj (contractEdgeProj x y u') (contractEdgeProj x y v') := by
            grind;
          apply SimpleGraph.contractEdge_adj_lift G x y u' v';
          · grind;
          · intro h; simp_all
          · exact h_adj;
        · tauto;
        · grind

/-
If a vertex is not one of the endpoints of the contracted edge, its projection is not the contracted vertex.
-/
lemma SimpleGraph.contractEdgeProj_ne_vertex_of_ne {V : Type*} [DecidableEq V] (x y v : V) (h : v ≠ x ∧ v ≠ y) :
  SimpleGraph.contractEdgeProj x y v ≠ SimpleGraph.contractEdge_vertex x y := by
    exact fun h' => h.1 ( by have := contractEdgeProj_eq_vertex_iff x y v; tauto )

/-
The map from vertices avoiding x and y to vertices avoiding the contracted vertex.
-/
def SimpleGraph.contractEdge_avoiding_iso_fun {V : Type*} [DecidableEq V] (x y : V) :
  {v : V // v ≠ x ∧ v ≠ y} → {v : Quotient (SimpleGraph.contractEdgeSetoid x y) // v ≠ SimpleGraph.contractEdge_vertex x y} :=
  fun ⟨v, hv⟩ => ⟨SimpleGraph.contractEdgeProj x y v, SimpleGraph.contractEdgeProj_ne_vertex_of_ne x y v hv⟩

/-
The map from vertices avoiding x and y to vertices avoiding the contracted vertex is a bijection.
-/
lemma SimpleGraph.contractEdge_avoiding_iso_bijective {V : Type*} [DecidableEq V] (x y : V) :
  Function.Bijective (SimpleGraph.contractEdge_avoiding_iso_fun x y) := by
    refine' ⟨ _, _ ⟩;
    · intro ⟨ v, hv ⟩ ⟨ w, hw ⟩ h_eq
      have h_proj : SimpleGraph.contractEdgeProj x y v = SimpleGraph.contractEdgeProj x y w := by
        injection h_eq
      have h_ne : v ≠ x ∧ v ≠ y ∧ w ≠ x ∧ w ≠ y := by
        tauto
      have h_inj : v = w := by
        exact SimpleGraph.contractEdgeProj_inj_on x y v w ( by simp [ SimpleGraph.contractEdgeProj_ne_vertex_of_ne, h_ne ] ) ( by simp [ SimpleGraph.contractEdgeProj_ne_vertex_of_ne, h_ne ] ) h_proj
      exact Subtype.ext h_inj;
    · intro z
      obtain ⟨v, hv⟩ : ∃ v : V, SimpleGraph.contractEdgeProj x y v = z := by
        exact Quotient.exists_rep z.1
      obtain ⟨hv_ne_x, hv_ne_y⟩ : v ≠ x ∧ v ≠ y := by
        constructor <;> intro <;> simp_all
        · exact z.2 ( hv.symm );
        · exact z.2 ( hv.symm.trans ( Quotient.sound ( by tauto ) ) )
      use ⟨v, hv_ne_x, hv_ne_y⟩
      aesop

/-
If a walk maps to a path via a function that is injective on the walk's support, then the walk is a path.
-/
lemma SimpleGraph.Walk.isPath_of_map_isPath_injOn {V V' : Type*} [DecidableEq V] [DecidableEq V']
  {G : SimpleGraph V} {G' : SimpleGraph V'} (f : G →g G')
  {u v : V} (w : G.Walk u v)
  (h_inj : Set.InjOn f w.support.toFinset)
  (h_path : (w.map f).IsPath) : w.IsPath := by
    cases w <;> simp_all
    rename_i p hp;
    contrapose! h_path;
    intro h_path';
    have h_support : ∀ {u v : V} {p : G.Walk u v}, (p.map f).IsPath → p.IsPath := by
      intro u v p hp; induction p <;> aesop;
    specialize @h_support _ _ hp h_path' ; aesop

/-
Definitions for the subgraphs avoiding the contraction.
-/
def SimpleGraph.avoiding_set {V : Type*} [DecidableEq V] (x y : V) : Set V := {v | v ≠ x ∧ v ≠ y}

def SimpleGraph.contractEdge_avoiding_set {V : Type*} [DecidableEq V] (x y : V) : Set (Quotient (SimpleGraph.contractEdgeSetoid x y)) := {v | v ≠ SimpleGraph.contractEdge_vertex x y}

def SimpleGraph.avoiding_subgraph {V : Type*} [DecidableEq V] (G : SimpleGraph V) (x y : V) : SimpleGraph (SimpleGraph.avoiding_set x y) :=
  G.induce (SimpleGraph.avoiding_set x y)

def SimpleGraph.contractEdge_avoiding_subgraph {V : Type*} [DecidableEq V] (G : SimpleGraph V) (x y : V) : SimpleGraph (SimpleGraph.contractEdge_avoiding_set x y) :=
  (G.contractEdge' x y).induce (SimpleGraph.contractEdge_avoiding_set x y)

/-
Define deleting a single edge and prove it reduces edge count if the edge exists.
-/
def SimpleGraph.deleteEdge {V : Type*} (G : SimpleGraph V) (x y : V) : SimpleGraph V :=
  G.deleteEdges {Sym2.mk (x, y)}

lemma SimpleGraph.deleteEdge_edgeSet {V : Type*} (G : SimpleGraph V) (x y : V) :
  (G.deleteEdge x y).edgeSet = G.edgeSet \ {Sym2.mk (x, y)} := by
    ext ⟨ u, v ⟩ ; simp +decide [ SimpleGraph.deleteEdge ]

lemma SimpleGraph.deleteEdge_card_edges_lt {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (x y : V) (h : G.Adj x y) :
  (G.deleteEdge x y).edgeFinset.card < G.edgeFinset.card := by
    refine' Finset.card_lt_card _;
    refine' ⟨ fun e he => _, fun he => _ ⟩ <;> simp_all +decide [ SimpleGraph.deleteEdge ];
    · sorry

/-
A path in the contracted graph avoiding the contracted vertex lifts to a path in the original graph avoiding the contracted edge's endpoints (subset support).
-/
lemma SimpleGraph.lift_path_avoiding_contraction_AB {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) (x y : V)
  {u v : Quotient (SimpleGraph.contractEdgeSetoid x y)} (p : (G.contractEdge' x y).Walk u v)
  (hp_path : p.IsPath)
  (hp_avoid : SimpleGraph.contractEdge_vertex x y ∉ p.support)
  (hu : u ∈ SimpleGraph.contractEdge_liftSet x y A)
  (hv : v ∈ SimpleGraph.contractEdge_liftSet x y B) :
  ∃ (u' v' : V) (q : G.Walk u' v'),
    u' ∈ A ∧ v' ∈ B ∧
    SimpleGraph.contractEdgeProj x y u' = u ∧
    SimpleGraph.contractEdgeProj x y v' = v ∧
    q.IsPath ∧
    (q.support.toFinset.image (SimpleGraph.contractEdgeProj x y)) ⊆ p.support.toFinset ∧
    x ∉ q.support ∧ y ∉ q.support := by
      have := @SimpleGraph.lift_walk_avoiding_contraction V _ _ G x y u v p hp_avoid;
      obtain ⟨ u', v', q, hu', hv', hq ⟩ := this;
      refine' ⟨ u', v', q.toPath, _, _, hu', hv', _, _, _ ⟩ <;> simp_all +decide [ SimpleGraph.Walk.isPath_def ];
      · obtain ⟨ w, hw, rfl ⟩ := hu;
        cases eq_or_ne u' x <;> cases eq_or_ne u' y <;> cases eq_or_ne w x <;> cases eq_or_ne w y <;> simp_all +decide [ SimpleGraph.contractEdgeProj ];
        all_goals unfold contractEdgeSetoid at hu'; sorry
      · obtain ⟨ w, hw ⟩ := hv;
        have h_inj : ∀ a b : V, SimpleGraph.contractEdgeProj x y a = SimpleGraph.contractEdgeProj x y b → a = b ∨ a = x ∧ b = y ∨ a = y ∧ b = x := by
          intro a b hab; erw [ Quotient.eq ] at hab; aesop;
        cases h_inj _ _ ( hv'.trans hw.2.symm ) <;> aesop;
      · rw [ ← hq.1 ];
        simp +decide [ Finset.subset_iff ];
        intro a ha;
        exact ⟨ a, by simpa using SimpleGraph.Walk.support_toPath_subset q ha, rfl ⟩;
      · exact ⟨ fun h => hq.2.1 <| by simpa using q.support_bypass_subset h, fun h => hq.2.2 <| by simpa using q.support_bypass_subset h ⟩

/-
If a vertex is adjacent to the contracted vertex in the quotient graph, then it is adjacent to one of the endpoints of the contracted edge in the original graph.
-/
lemma SimpleGraph.contractEdge_adj_lift_vertex {V : Type*} [DecidableEq V] (G : SimpleGraph V) (x y : V) (u : V)
  (hu : SimpleGraph.contractEdgeProj x y u ≠ SimpleGraph.contractEdge_vertex x y) :
  (G.contractEdge' x y).Adj (SimpleGraph.contractEdgeProj x y u) (SimpleGraph.contractEdge_vertex x y) → G.Adj u x ∨ G.Adj u y := by
    rintro ⟨ a, ha ⟩;
    rcases ha with ( ⟨ a', b', ha', hb', hab ⟩ | ⟨ a', b', ha', hb', hab ⟩ );
    · simp_all +decide [ Quotient.eq, contractEdgeProj, contractEdge_vertex ];
      unfold contractEdgeSetoid at *; aesop;
    · rw [ eq_comm ] at ha' hb';
      cases eq_or_ne a' x <;> cases eq_or_ne a' y <;> cases eq_or_ne b' x <;> cases eq_or_ne b' y <;> simp_all +decide [ SimpleGraph.contractEdge_vertex, SimpleGraph.contractEdgeProj ];
      all_goals unfold contractEdgeSetoid at *; simp_all +decide [ SimpleGraph.adj_comm ] ;
      all_goals sorry

/-
The number of edges in the contracted graph is strictly less than in the original graph.
-/
lemma SimpleGraph.contractEdge_edge_card_lt {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (x y : V) (h : G.Adj x y) :
  (G.contractEdge' x y).edgeFinset.card < G.edgeFinset.card := by
    have h_inter : Finset.card (G.contractEdge' x y).edgeFinset ≤ Finset.card (G.edgeFinset \ {Sym2.mk (x, y)}) := by
      have h_inter : (G.contractEdge' x y).edgeFinset ⊆ Finset.image (fun e => Sym2.map (SimpleGraph.contractEdgeProj x y) e) (G.edgeFinset \ {Sym2.mk (x, y)}) := by
        intro e he; simp_all +decide [ SimpleGraph.contractEdge' ] ;
        rcases e with ⟨ a, b ⟩ ; simp_all +decide [ fromRel ] ;
        rcases he.2 with ( ⟨ a', rfl, b', rfl, hab ⟩ | ⟨ a', rfl, b', rfl, hab ⟩ ) <;> use Sym2.mk ( a', b' ) <;> simp_all +decide [ Sym2.eq_swap ];
        · sorry
        · sorry
      exact le_trans ( Finset.card_le_card h_inter ) ( Finset.card_image_le );
    exact lt_of_le_of_lt h_inter ( Finset.card_lt_card ( Finset.ssubset_iff_subset_ne.mpr ⟨ Finset.sdiff_subset, by aesop ⟩ ) )

/-
If a walk's support intersects {x, y} only at v (or not at all), then the walk does not use the edge xy.
-/
lemma SimpleGraph.Walk.edges_no_xy_of_support_inter_subset_one {V : Type*} [DecidableEq V] {G : SimpleGraph V}
  {u v : V} (p : G.Walk u v) (x y : V) (hxy : x ≠ y)
  (h : p.support.toFinset ∩ {x, y} ⊆ {v}) :
  Sym2.mk (x, y) ∉ p.edges := by
    contrapose! h;
    simp_all +decide [ Finset.eq_singleton_iff_unique_mem ];
    -- If the edge {x, y} is in the walk's edges, then both x and y must be in the walk's support.
    have h_support : x ∈ p.support ∧ y ∈ p.support := by
      induction p <;> aesop;
    aesop

/-
If a walk intersects X, there is a prefix walk ending in X that avoids X internally.
-/
lemma SimpleGraph.Walk.exists_walk_prefix_avoiding_set {V : Type*} [DecidableEq V] {G : SimpleGraph V} {u v : V} (p : G.Walk u v) (X : Set V) (h : ∃ w ∈ p.support, w ∈ X) :
  ∃ (w : V) (q : G.Walk u w), w ∈ X ∧ q.support.toFinset ⊆ p.support.toFinset ∧ (∀ z ∈ q.support, z ∈ X → z = w) := by
    revert h p;
    -- We'll use induction on the length of the walk.
    intro p hp
    induction' p with u v p ih;
    · simp_all +decide [ SimpleGraph.Walk.support ];
      exact ⟨ u, hp, SimpleGraph.Walk.nil, by simp +decide ⟩;
    · rename_i h₁ h₂ h₃;
      by_cases h : v ∈ X;
      · refine' ⟨ v, SimpleGraph.Walk.nil, h, _, _ ⟩ <;> simp +decide [ h ];
      · rcases h₃ ( by cases hp; aesop ) with ⟨ w, q, hw, hq₁, hq₂ ⟩ ; use w, cons h₁ q ; aesop;

/-
If a path intersects X, there is a prefix path ending in X that avoids X internally.
-/
lemma SimpleGraph.Walk.exists_path_prefix_avoiding_set {V : Type*} [DecidableEq V] {G : SimpleGraph V} {u v : V} (p : G.Walk u v) (_ : p.IsPath) (X : Set V) (h : ∃ w ∈ p.support, w ∈ X) :
  ∃ (w : V) (q : G.Walk u w), w ∈ X ∧ q.IsPath ∧ q.support.toFinset ⊆ p.support.toFinset ∧ (∀ z ∈ q.support, z ∈ X → z = w) := by
    obtain ⟨ w, hw₁, hw₂ ⟩ := h;
    obtain ⟨ q, hq₁, hq₂ ⟩ := p.exists_walk_prefix_avoiding_set X ⟨ w, hw₁, hw₂ ⟩;
    refine' ⟨ q, hq₁.toPath, hq₂.1, _, _, _ ⟩ <;> simp_all +decide [ SimpleGraph.Walk.isPath_def ];
    · simp_all +decide [ Finset.subset_iff ];
      exact fun x hx => hq₂.2.1 ( SimpleGraph.Walk.support_bypass_subset hq₁ hx );
    · intro z hz hzX; specialize hq₂; have := hq₂.2.2 z; simp_all
      exact hq₂.2.2 z ( by simpa using hq₁.support_bypass_subset hz ) hzX

/-
If X separates A and B in G and contains x and y, then any separator of A and X in G-xy is also a separator of A and B in G.
-/
lemma SimpleGraph.separator_in_G_of_separator_in_G_delete_edge {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) (x y : V) (X : Finset V) (S : Finset V)
  (hX : G.Separates A B X) (hx : x ∈ X) (hy : y ∈ X) (hxy : x ≠ y)
  (hS : (G.deleteEdge x y).Separates A X S) :
  G.Separates A B S := by
    -- Let P be an A-B path in G.
    intro u hu v hv p hp
    obtain ⟨w, q, hwX, hqpath, hq_support, hq_avoid⟩ : ∃ (w : V) (q : G.Walk u w), w ∈ X ∧ q.IsPath ∧ q.support.toFinset ⊆ p.support.toFinset ∧ (∀ z ∈ q.support, z ∈ X → z = w) := by
      apply_rules [ SimpleGraph.Walk.exists_path_prefix_avoiding_set ];
    -- Since x, y ∈ X, q avoids {x, y} internally.
    have hq_avoid_xy : Sym2.mk (x, y) ∉ q.edges := by
      apply SimpleGraph.Walk.edges_no_xy_of_support_inter_subset_one q x y hxy;
      intro z hz; specialize hq_avoid z; aesop;
    -- Since q is a path in G-xy, it follows that q is a path in G-xy.
    have hq_path_G_minus_xy : ∃ q' : (G.deleteEdge x y).Walk u w, q'.IsPath ∧ q'.support.toFinset ⊆ q.support.toFinset := by
      have hq_path_G_minus_xy : ∀ {u v : V} (q : G.Walk u v), q.IsPath → Sym2.mk (x, y) ∉ q.edges → ∃ q' : (G.deleteEdge x y).Walk u v, q'.IsPath ∧ q'.support.toFinset ⊆ q.support.toFinset := by
        intro u v q hq hq_avoid_xy
        induction' q with u v q ih;
        · exact ⟨ SimpleGraph.Walk.nil, by simp +decide ⟩;
        · rename_i h₁ h₂ h₃;
          simp_all +decide [ SimpleGraph.Walk.cons_isPath_iff ];
          obtain ⟨ q', hq'_path, hq'_support ⟩ := h₃;
          refine' ⟨ SimpleGraph.Walk.cons _ q', _, _ ⟩ <;> simp_all +decide [ Finset.subset_iff ];
          · unfold SimpleGraph.deleteEdge; aesop;
          · exact fun h => hq.2 ( by simpa using hq'_support ( by simpa using h ) );
          · intro a ha; specialize hq'_support ( List.mem_toFinset.mpr ha ) ; aesop;
      exact hq_path_G_minus_xy q hqpath hq_avoid_xy;
    obtain ⟨ q', hq'_path, hq'_support ⟩ := hq_path_G_minus_xy;
    have := hS u hu w hwX q' hq'_path; simp_all +decide [ SimpleGraph.Walk.isPath_def ] ;
    obtain ⟨ z, hz₁, hz₂ ⟩ := this; exact ⟨ z, by simpa using hq'_support ( by simpa using hz₁ ) |> fun h => hq_support h, hz₂ ⟩ ;
