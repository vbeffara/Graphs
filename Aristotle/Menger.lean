/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7b68ab0a-0995-4676-996d-1d38e53d9b5a

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 92285974-ca7c-4130-b513-da721c60ddd6

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check SimpleGraph
#check SimpleGraph.Walk

/-
A set of vertices S separates A from B in G if every A-B path in G contains a vertex from S.
-/
def SimpleGraph.Separates {V : Type*} (G : SimpleGraph V) (A B : Set V) (S : Finset V) : Prop :=
  ∀ u ∈ A, ∀ v ∈ B, ∀ p : G.Walk u v, p.IsPath → ∃ x ∈ p.support, x ∈ S

/-
An A-B path is a path in G starting in A and ending in B.
-/
structure SimpleGraph.ABPath {V : Type*} (G : SimpleGraph V) (A B : Set V) where
  u : V
  v : V
  walk : G.Walk u v
  is_path : walk.IsPath
  start_in_A : u ∈ A
  end_in_B : v ∈ B

/-
A set of A-B paths is disjoint if any two distinct paths in the set are vertex-disjoint.
-/
def SimpleGraph.DisjointPaths {V : Type*} [DecidableEq V] (G : SimpleGraph V) (A B : Set V) (P : Finset (G.ABPath A B)) : Prop :=
  ∀ p ∈ P, ∀ q ∈ P, p ≠ q → Disjoint p.walk.support.toFinset q.walk.support.toFinset

/-
Check if Fintype instance for SimpleGraph.Path exists.
-/
#check SimpleGraph.Path.instFintype

/-
The set of A-B paths is finite.
-/
instance SimpleGraph.ABPath.instFinite {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) : Finite (G.ABPath A B) := by
  -- Since the vertex set is finite, the set of all possible paths between any two vertices is also finite. We can use the fact that the set of all paths between any two vertices is finite.
  have h_finite_paths : ∀ u v : V, Set.Finite {p : G.Walk u v | p.IsPath} := by
    intro u v
    have h_finite_walks : Set.Finite {p : G.Walk u v | p.length ≤ Fintype.card V} := by
      have h_finite_walks : ∀ n : ℕ, Set.Finite {p : G.Walk u v | p.length = n} := by
        exact?;
      exact Set.Finite.subset ( Set.Finite.biUnion ( Set.finite_Iic ( Fintype.card V ) ) fun n hn => h_finite_walks n ) fun p hp => by aesop;
    refine' h_finite_walks.subset fun p hp => _;
    have := hp.length_lt;
    exact le_of_lt this;
  -- Since A and B are finite, the set of pairs (u, v) where u is in A and v is in B is also finite.
  have h_finite_pairs : Set.Finite {p : V × V | p.1 ∈ A ∧ p.2 ∈ B} := by
    exact Set.toFinite _;
  have h_finite_paths : Set.Finite {p : Σ u : V, Σ v : V, G.Walk u v | p.1 ∈ A ∧ p.2.1 ∈ B ∧ p.2.2.IsPath} := by
    have h_finite_paths : Set.Finite (⋃ p ∈ {p : V × V | p.1 ∈ A ∧ p.2 ∈ B}, {q : Σ u : V, Σ v : V, G.Walk u v | q.1 = p.1 ∧ q.2.1 = p.2 ∧ q.2.2.IsPath}) := by
      refine' Set.Finite.biUnion h_finite_pairs fun p hp => _;
      exact Set.Finite.subset ( Set.Finite.image ( fun q : G.Walk p.1 p.2 => ⟨ p.1, p.2, q ⟩ ) ( h_finite_paths p.1 p.2 ) ) fun q hq => by aesop;
    exact h_finite_paths.subset fun p hp => by aesop;
  convert h_finite_paths.of_injective _ _;
  exact fun p => ⟨ ⟨ p.u, p.v, p.walk ⟩, p.start_in_A, p.end_in_B, p.is_path ⟩;
  intro p q h; cases p; cases q; aesop;

noncomputable instance SimpleGraph.ABPath.instFintype {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) : Fintype (G.ABPath A B) := Fintype.ofFinite _

/-
The set of all vertex sets that separate A from B.
-/
def SimpleGraph.separators {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) : Finset (Finset V) :=
  (Finset.powerset Finset.univ).filter (fun S => G.Separates A B S)

/-
The set of all sets of disjoint A-B paths.
-/
noncomputable def SimpleGraph.disjoint_path_sets {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) : Finset (Finset (G.ABPath A B)) :=
  (Finset.powerset Finset.univ).filter (fun P => G.DisjointPaths A B P)

/-
The set of separators is nonempty (e.g., the set of all vertices is a separator).
-/
lemma SimpleGraph.separators_nonempty {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) :
  (G.separators A B).Nonempty := by
    refine' ⟨ Finset.univ, _ ⟩;
    -- Since the universal set contains all vertices, any path between A and B must pass through some vertex in the universal set.
    simp [SimpleGraph.separators];
    exact fun u hu v hv p hp => ⟨ u, p.start_mem_support, Finset.mem_univ _ ⟩

/-
The set of disjoint path sets is nonempty (the empty set is a valid set of disjoint paths).
-/
lemma SimpleGraph.disjoint_path_sets_nonempty {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) :
  (G.disjoint_path_sets A B).Nonempty := by
  use ∅
  simp [disjoint_path_sets, DisjointPaths]

/-
The minimum size of a separator and the maximum number of disjoint paths.
-/
noncomputable def SimpleGraph.min_separator_size {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) : ℕ :=
  ((G.separators A B).image Finset.card).min' ((G.separators_nonempty A B).image Finset.card)

noncomputable def SimpleGraph.max_disjoint_paths_size {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) : ℕ :=
  ((G.disjoint_path_sets A B).image Finset.card).max' ((G.disjoint_path_sets_nonempty A B).image Finset.card)

/-
The maximum number of disjoint A-B paths is at most the minimum size of an A-B separator.
-/
theorem SimpleGraph.Menger_weak {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) :
  G.max_disjoint_paths_size A B ≤ G.min_separator_size A B := by
    by_contra h_contra;
    -- Let $\mathcal{P}$ be a set of $m$ disjoint A-B paths.
    obtain ⟨P, hP⟩ : ∃ P : Finset (G.ABPath A B), G.DisjointPaths A B P ∧ P.card > G.min_separator_size A B := by
      simp_all +decide [ SimpleGraph.max_disjoint_paths_size ];
      unfold SimpleGraph.disjoint_path_sets at h_contra; aesop;
    -- Let $S$ be an A-B separator of size $k$.
    obtain ⟨S, hS⟩ : ∃ S : Finset V, G.Separates A B S ∧ S.card = G.min_separator_size A B := by
      have := Finset.min'_mem ( ( G.separators A B ).image Finset.card ) ⟨ _, Finset.mem_image_of_mem _ ( Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( Finset.subset_univ ( Finset.univ : Finset V ) ), ( Finset.mem_filter.mp ( Finset.mem_filter.mpr ⟨ Finset.mem_powerset.mpr ( Finset.subset_univ ( Finset.univ : Finset V ) ), ( fun u hu v hv p hp ↦ by
        cases p <;> aesop ) ⟩ ) |>.2 ) ⟩ ) ⟩
      generalize_proofs at *;
      rw [ Finset.mem_image ] at this; obtain ⟨ S, hS₁, hS₂ ⟩ := this; exact ⟨ S, Finset.mem_filter.mp hS₁ |>.2, hS₂ ⟩ ;
    -- Since $S$ is an A-B separator, every path in $\mathcal{P}$ must contain at least one vertex from $S$.
    have h_path_inter_S : ∀ p ∈ P, ∃ x ∈ p.walk.support, x ∈ S := by
      exact fun p hp => hS.1 p.u p.start_in_A p.v p.end_in_B p.walk p.is_path;
    have h_path_inter_S : Finset.card (Finset.biUnion P (fun p => p.walk.support.toFinset ∩ S)) ≥ P.card := by
      rw [ Finset.card_biUnion ];
      · exact Finset.card_eq_sum_ones P ▸ Finset.sum_le_sum fun p hp => Finset.card_pos.mpr ⟨ Classical.choose ( h_path_inter_S p hp ), Finset.mem_inter.mpr ⟨ by simpa using Classical.choose_spec ( h_path_inter_S p hp ) |>.1, by simpa using Classical.choose_spec ( h_path_inter_S p hp ) |>.2 ⟩ ⟩;
      · intro p hp q hq hpq; specialize hP; have := hP.1 p hp q hq hpq; simp_all +decide [ Finset.disjoint_left ] ;
    exact h_path_inter_S.not_lt ( lt_of_le_of_lt ( Finset.card_le_card ( Finset.biUnion_subset.mpr fun p hp => Finset.inter_subset_right ) ) ( by linarith ) )

/-
Base case of Menger's theorem: if G has no edges, the theorem holds.
-/
lemma SimpleGraph.Menger_strong_base {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) (h : G.edgeSet = ∅) :
  G.min_separator_size A B ≤ G.max_disjoint_paths_size A B := by
    have h_empty : ∀ u v, G.Walk u v → u = v := by
      intro u v p; induction p <;> aesop;
    unfold SimpleGraph.min_separator_size SimpleGraph.max_disjoint_paths_size;
    simp +decide [ SimpleGraph.separators, SimpleGraph.disjoint_path_sets ];
    simp +decide [ Finset.min', Finset.max', SimpleGraph.Separates ];
    refine' ⟨ Finset.filter ( fun p => p.u = p.v ∧ p.u ∈ A ∩ B ) ( Finset.univ : Finset ( G.ABPath A B ) ), _, Finset.image ( fun p => p.u ) ( Finset.filter ( fun p => p.u = p.v ∧ p.u ∈ A ∩ B ) ( Finset.univ : Finset ( G.ABPath A B ) ) ), _, _ ⟩;
    · intro p hp q hq hpq;
      cases p ; cases q ; aesop;
    · intro u hu v hv p hp;
      obtain rfl := h_empty u v p;
      exact ⟨ u, by simp, Finset.mem_image.mpr ⟨ ⟨ u, u, p, hp, hu, hv ⟩, by aesop ⟩ ⟩;
    · exact Finset.card_image_le

/-
The contraction of edge (x, y) in G.
-/
def SimpleGraph.contractEdge {V : Type*} [DecidableEq V] (G : SimpleGraph V) (x y : V) : SimpleGraph (Quotient (Setoid.mk (fun a b => a = b ∨ (a = x ∧ b = y) ∨ (a = y ∧ b = x)) (by
constructor <;> aesop
))) :=
  let s := Setoid.mk (fun a b => a = b ∨ (a = x ∧ b = y) ∨ (a = y ∧ b = x)) (by
  constructor <;> aesop
  )
  SimpleGraph.fromRel (fun a b => ∃ a' b', Quotient.mk s a' = a ∧ Quotient.mk s b' = b ∧ G.Adj a' b')

/-
Definitions for edge contraction: the setoid identifying the endpoints, the contracted graph, and the projection map.
-/
def SimpleGraph.contractEdgeSetoid {V : Type*} [DecidableEq V] (x y : V) : Setoid V :=
  Setoid.mk (fun a b => a = b ∨ (a = x ∧ b = y) ∨ (a = y ∧ b = x)) (by
  constructor <;> aesop
  )

def SimpleGraph.contractEdge' {V : Type*} [DecidableEq V] (G : SimpleGraph V) (x y : V) : SimpleGraph (Quotient (SimpleGraph.contractEdgeSetoid x y)) :=
  SimpleGraph.fromRel (fun a b => ∃ a' b', Quotient.mk (SimpleGraph.contractEdgeSetoid x y) a' = a ∧ Quotient.mk (SimpleGraph.contractEdgeSetoid x y) b' = b ∧ G.Adj a' b')

def SimpleGraph.contractEdgeProj {V : Type*} [DecidableEq V] (x y : V) : V → Quotient (SimpleGraph.contractEdgeSetoid x y) :=
  Quotient.mk (SimpleGraph.contractEdgeSetoid x y)

/-
Check if contractEdgeSetoid and contractEdge' are defined.
-/
#check SimpleGraph.contractEdgeSetoid
#check SimpleGraph.contractEdge'

/-
The number of vertices in the contracted graph is strictly less than in the original graph (if x != y). Also define the image of a set under contraction.
-/
lemma SimpleGraph.contractEdge_card_lt {V : Type*} [Fintype V] [DecidableEq V] (x y : V) (h : x ≠ y) :
  Fintype.card (Quotient (SimpleGraph.contractEdgeSetoid x y)) < Fintype.card V := by
    have h_card : Fintype.card (Quotient (SimpleGraph.contractEdgeSetoid x y)) ≤ Finset.card (Finset.image (fun z => Quotient.mk (SimpleGraph.contractEdgeSetoid x y) z) (Finset.univ.erase x)) := by
      have h_card : Finset.image (fun z => Quotient.mk (SimpleGraph.contractEdgeSetoid x y) z) (Finset.univ.erase x) = Finset.univ := by
        ext z
        simp [Finset.mem_image];
        obtain ⟨ a, rfl ⟩ := Quotient.exists_rep z;
        by_cases ha : a = x;
        · exact ⟨ y, by tauto, by rw [ ha ] ; exact Quotient.sound ( by tauto ) ⟩;
        · exact ⟨ a, ha, rfl ⟩;
      rw [ h_card, Finset.card_univ ];
    grind

def SimpleGraph.contractEdge_liftSet {V : Type*} [DecidableEq V] (x y : V) (S : Set V) : Set (Quotient (SimpleGraph.contractEdgeSetoid x y)) :=
  S.image (SimpleGraph.contractEdgeProj x y)

/-
Checking Sym2 notation
-/
#check Sym2
#check Sym2.mk

/-
Checking SimpleGraph.Path definition
-/
#check SimpleGraph.Path

/-
Given a walk in G, there exists a walk in the contracted graph G/e between the projected endpoints, whose support is contained in the image of the original walk's support.
-/
lemma SimpleGraph.exists_walk_of_path_contraction {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (x y : V)
  {u v : V} (p : G.Walk u v) :
  ∃ (w : (G.contractEdge' x y).Walk (SimpleGraph.contractEdgeProj x y u) (SimpleGraph.contractEdgeProj x y v)),
    w.support.toFinset ⊆ p.support.toFinset.image (SimpleGraph.contractEdgeProj x y) := by
      induction' p with u v p ih;
      · exact ⟨ SimpleGraph.Walk.nil, by simp +decide ⟩;
      · simp +zetaDelta at *;
        cases' ‹∃ w, _› with w hw;
        by_cases h : contractEdgeProj x y v = contractEdgeProj x y p;
        · grind;
        · have h_adj : (G.contractEdge' x y).Adj (contractEdgeProj x y v) (contractEdgeProj x y p) := by
            unfold SimpleGraph.contractEdge';
            aesop;
          refine' ⟨ SimpleGraph.Walk.cons h_adj w, _ ⟩;
          simp_all +decide [ Finset.subset_iff ]

/-
The preimage of a set of vertices in the contracted graph.
-/
def SimpleGraph.contractEdge_preimage {V : Type*} [Fintype V] [DecidableEq V] (x y : V) (Y : Finset (Quotient (SimpleGraph.contractEdgeSetoid x y))) : Finset V :=
  Finset.univ.filter (fun v => SimpleGraph.contractEdgeProj x y v ∈ Y)

/-
If a set of vertices separates A and B in the contracted graph G/e, then its preimage separates A and B in G.
-/
lemma SimpleGraph.contractEdge_preimage_separates {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (A B : Set V) (x y : V)
  (Y : Finset (Quotient (SimpleGraph.contractEdgeSetoid x y)))
  (hY : (G.contractEdge' x y).Separates (SimpleGraph.contractEdge_liftSet x y A) (SimpleGraph.contractEdge_liftSet x y B) Y) :
  G.Separates A B (SimpleGraph.contractEdge_preimage x y Y) := by
    intro u hu v hv p hp;
    obtain ⟨ w, hw ⟩ := SimpleGraph.exists_walk_of_path_contraction G x y p;
    -- Since $w$ is a path in the contracted graph from $\pi(u)$ to $\pi(v)$, and $Y$ separates $\pi(A)$ and $\pi(B)$ in the contracted graph, $w$ must intersect $Y$.
    obtain ⟨ z, hzY, hzw ⟩ : ∃ z ∈ Y, z ∈ w.support := by
      specialize hY (contractEdgeProj x y u) (by
      exact Set.mem_image_of_mem _ hu) (contractEdgeProj x y v) (by
      exact Set.mem_image_of_mem _ hv) w.toPath;
      exact hY ( SimpleGraph.Walk.bypass_isPath _ ) |> fun ⟨ z, hz₁, hz₂ ⟩ => ⟨ z, hz₂, by simpa using SimpleGraph.Walk.support_bypass_subset _ hz₁ ⟩;
    have := hw ( by simpa using hzw );
    simp +zetaDelta at *;
    exact ⟨ this.choose, this.choose_spec.1, Finset.mem_filter.mpr ⟨ Finset.mem_univ _, this.choose_spec.2.symm ▸ hzY ⟩ ⟩

/-
The contracted vertex in the quotient graph.
-/
def SimpleGraph.contractEdge_vertex {V : Type*} [DecidableEq V] (x y : V) : Quotient (SimpleGraph.contractEdgeSetoid x y) :=
  Quotient.mk (SimpleGraph.contractEdgeSetoid x y) x

lemma SimpleGraph.contractEdge_vertex_eq {V : Type*} [DecidableEq V] (x y : V) :
  SimpleGraph.contractEdge_vertex x y = Quotient.mk (SimpleGraph.contractEdgeSetoid x y) y := by
  apply Quotient.sound
  right
  left
  exact ⟨rfl, rfl⟩

/-
A vertex projects to the contracted vertex if and only if it is one of the endpoints of the contracted edge.
-/
lemma SimpleGraph.contractEdgeProj_eq_vertex_iff {V : Type*} [DecidableEq V] (x y u : V) :
  SimpleGraph.contractEdgeProj x y u = SimpleGraph.contractEdgeProj x y x ↔ u = x ∨ u = y := by
    -- By definition of the projection, we have that the projection of u is equal to the projection of x if and only if u is equivalent to x under the setoid.
    simp [SimpleGraph.contractEdgeProj, Setoid.r];
    simp [contractEdgeSetoid];
    grind

/-
The projection map is injective on vertices that do not map to the contracted vertex.
-/
lemma SimpleGraph.contractEdgeProj_inj_on {V : Type*} [DecidableEq V] (x y : V) (u v : V)
  (hu : SimpleGraph.contractEdgeProj x y u ≠ SimpleGraph.contractEdge_vertex x y)
  (hv : SimpleGraph.contractEdgeProj x y v ≠ SimpleGraph.contractEdge_vertex x y) :
  SimpleGraph.contractEdgeProj x y u = SimpleGraph.contractEdgeProj x y v → u = v := by
    -- If the projections are equal, then u and v must be in the same equivalence class.
    intro h_eq
    have h_equiv : u = v ∨ (u = x ∧ v = y) ∨ (u = y ∧ v = x) := by
      erw [ Quotient.eq ] at h_eq ; aesop;
    tauto

/-
If the projections of two vertices are adjacent in the contracted graph and neither projects to the contracted vertex, then the original vertices are adjacent in the original graph.
-/
lemma SimpleGraph.contractEdge_adj_lift {V : Type*} [DecidableEq V] (G : SimpleGraph V) (x y : V) (u v : V)
  (hu : SimpleGraph.contractEdgeProj x y u ≠ SimpleGraph.contractEdge_vertex x y)
  (hv : SimpleGraph.contractEdgeProj x y v ≠ SimpleGraph.contractEdge_vertex x y) :
  (G.contractEdge' x y).Adj (SimpleGraph.contractEdgeProj x y u) (SimpleGraph.contractEdgeProj x y v) → G.Adj u v := by
    rintro ⟨ a, b, ha, hb, hab ⟩;
    · unfold SimpleGraph.contractEdgeProj at *;
      unfold contractEdge_vertex at *; simp_all +decide [ Quotient.eq ] ;
      unfold contractEdgeSetoid at *; aesop;
    · -- Apply the lemma that states if the projections of two vertices are adjacent and neither is the contracted vertex, then the original vertices are adjacent.
      have h_adj : contractEdgeProj x y v ≠ contractEdge_vertex x y → contractEdgeProj x y u ≠ contractEdge_vertex x y → (G.contractEdge' x y).Adj (contractEdgeProj x y v) (contractEdgeProj x y u) → G.Adj v u := by
        unfold SimpleGraph.contractEdgeProj at *;
        unfold SimpleGraph.contractEdge_vertex at *; simp_all +decide [ Quotient.eq ] ;
        unfold contractEdgeSetoid at *; aesop;
      simp_all +decide [ SimpleGraph.adj_comm ];
      unfold SimpleGraph.contractEdge' at *; aesop;

/-
The size of the preimage of a set of vertices in the contracted graph.
-/
lemma SimpleGraph.card_preimage_contractEdge {V : Type*} [Fintype V] [DecidableEq V] (x y : V) (h : x ≠ y)
  (Y : Finset (Quotient (SimpleGraph.contractEdgeSetoid x y))) :
  (SimpleGraph.contractEdge_preimage x y Y).card = if SimpleGraph.contractEdge_vertex x y ∈ Y then Y.card + 1 else Y.card := by
    unfold contractEdge_preimage;
    -- Let's count the number of elements in the preimage of Y.
    have h_card_preimage : (Finset.univ.filter (fun v => SimpleGraph.contractEdgeProj x y v ∈ Y)).card = ∑ z ∈ Y, (Finset.univ.filter (fun v => SimpleGraph.contractEdgeProj x y v = z)).card := by
      simp +decide only [Finset.card_filter];
      rw [ Finset.sum_comm, Finset.sum_congr rfl ] ; aesop;
    -- Let's count the number of elements in each fiber of the projection map.
    have h_fiber_card : ∀ z ∈ Y, (Finset.univ.filter (fun v => SimpleGraph.contractEdgeProj x y v = z)).card = if z = SimpleGraph.contractEdge_vertex x y then 2 else 1 := by
      intro z hz
      by_cases hz_eq : z = SimpleGraph.contractEdge_vertex x y;
      · simp [hz_eq];
        rw [ Finset.card_eq_two ];
        refine' ⟨ x, y, h, _ ⟩;
        ext v; simp [contractEdgeProj, contractEdge_vertex];
        exact ⟨ fun h => by cases h <;> tauto, fun h => by cases h <;> tauto ⟩;
      · obtain ⟨ v, rfl ⟩ := Quotient.exists_rep z;
        simp +decide [ SimpleGraph.contractEdgeProj, SimpleGraph.contractEdge_vertex, hz_eq ];
        split_ifs with h;
        · exact False.elim ( hz_eq ( Quotient.sound h ) );
        · rw [ Finset.card_eq_one ];
          use v; ext; simp [contractEdgeSetoid];
          unfold contractEdgeSetoid at h; aesop;
    split_ifs <;> simp_all +decide [ Finset.sum_ite ];
    · simp_all +decide [ Finset.filter_eq', Finset.filter_ne' ];
      linarith [ Nat.sub_add_cancel ( show 1 ≤ Y.card from Finset.card_pos.mpr ⟨ _, ‹_› ⟩ ) ];
    · simp_all +decide [ Finset.filter_eq', Finset.filter_ne' ]

/-
A walk in the contracted graph that avoids the contracted vertex can be lifted to a walk in the original graph.
-/
lemma SimpleGraph.lift_walk_avoiding_contraction {V : Type*} [Fintype V] [DecidableEq V] (G : SimpleGraph V) (x y : V)
  {u v : Quotient (SimpleGraph.contractEdgeSetoid x y)} (p : (G.contractEdge' x y).Walk u v)
  (hp : SimpleGraph.contractEdge_vertex x y ∉ p.support) :
  ∃ (u' v' : V) (q : G.Walk u' v'),
    SimpleGraph.contractEdgeProj x y u' = u ∧
    SimpleGraph.contractEdgeProj x y v' = v ∧
    (q.support.toFinset.image (SimpleGraph.contractEdgeProj x y)) = p.support.toFinset ∧
    x ∉ q.support ∧ y ∉ q.support := by
      induction' p with u v p ih;
      · obtain ⟨ u', rfl ⟩ := Quotient.exists_rep u;
        by_cases hu : u' = x ∨ u' = y;
        · cases hu <;> simp_all +decide [ contractEdge_vertex ];
          exact False.elim ( hp ( by tauto ) );
        · refine' ⟨ u', u', SimpleGraph.Walk.nil, _, _, _, _ ⟩ <;> simp_all +decide [ SimpleGraph.contractEdgeProj ];
          tauto;
      · rename_i h₁ h₂;
        -- Since v is not the contracted vertex, there exists a unique u' in V such that contractEdgeProj x y u' = v.
        obtain ⟨u', hu'⟩ : ∃ u' : V, contractEdgeProj x y u' = v ∧ u' ≠ x ∧ u' ≠ y := by
          rcases Quotient.exists_rep v with ⟨ u', rfl ⟩;
          refine' ⟨ u', rfl, _, _ ⟩ <;> contrapose! hp <;> simp_all +decide [ contractEdge_vertex ];
          exact Or.inl ( by tauto );
        obtain ⟨ v', hv' ⟩ := h₂ ( by intro h; simp_all +decide [ SimpleGraph.Walk.support_cons ] );
        obtain ⟨ v'', q, hv'', hv''', hq, hx, hy ⟩ := hv';
        refine' ⟨ u', v'', SimpleGraph.Walk.cons _ q, hu'.1, hv''', _, _, _ ⟩ <;> simp_all +decide [ SimpleGraph.Walk.support_cons ];
        · have h_adj : (G.contractEdge' x y).Adj (contractEdgeProj x y u') (contractEdgeProj x y v') := by
            grind;
          apply SimpleGraph.contractEdge_adj_lift G x y u' v';
          · grind;
          · intro h; simp_all +decide [ SimpleGraph.Walk.support_cons ] ;
          · exact h_adj;
        · tauto;
        · grind

/-
If a vertex is not one of the endpoints of the contracted edge, its projection is not the contracted vertex.
-/
lemma SimpleGraph.contractEdgeProj_ne_vertex_of_ne {V : Type*} [DecidableEq V] (x y v : V) (h : v ≠ x ∧ v ≠ y) :
  SimpleGraph.contractEdgeProj x y v ≠ SimpleGraph.contractEdge_vertex x y := by
    exact fun h' => h.1 ( by have := contractEdgeProj_eq_vertex_iff x y v; tauto )

/-
The map from vertices avoiding x and y to vertices avoiding the contracted vertex.
-/
def SimpleGraph.contractEdge_avoiding_iso_fun {V : Type*} [DecidableEq V] (x y : V) (h : x ≠ y) :
  {v : V // v ≠ x ∧ v ≠ y} → {v : Quotient (SimpleGraph.contractEdgeSetoid x y) // v ≠ SimpleGraph.contractEdge_vertex x y} :=
  fun ⟨v, hv⟩ => ⟨SimpleGraph.contractEdgeProj x y v, SimpleGraph.contractEdgeProj_ne_vertex_of_ne x y v hv⟩

/-
The map from vertices avoiding x and y to vertices avoiding the contracted vertex is a bijection.
-/
lemma SimpleGraph.contractEdge_avoiding_iso_bijective {V : Type*} [DecidableEq V] (x y : V) (h : x ≠ y) :
  Function.Bijective (SimpleGraph.contractEdge_avoiding_iso_fun x y h) := by
    refine' ⟨ _, _ ⟩;
    · intro ⟨ v, hv ⟩ ⟨ w, hw ⟩ h_eq
      have h_proj : SimpleGraph.contractEdgeProj x y v = SimpleGraph.contractEdgeProj x y w := by
        injection h_eq
      have h_ne : v ≠ x ∧ v ≠ y ∧ w ≠ x ∧ w ≠ y := by
        tauto
      have h_inj : v = w := by
        exact SimpleGraph.contractEdgeProj_inj_on x y v w ( by simp [ SimpleGraph.contractEdgeProj_ne_vertex_of_ne, h_ne ] ) ( by simp [ SimpleGraph.contractEdgeProj_ne_vertex_of_ne, h_ne ] ) h_proj
      exact Subtype.ext h_inj;
    · intro z
      obtain ⟨v, hv⟩ : ∃ v : V, SimpleGraph.contractEdgeProj x y v = z := by
        exact Quotient.exists_rep z.1
      obtain ⟨hv_ne_x, hv_ne_y⟩ : v ≠ x ∧ v ≠ y := by
        constructor <;> intro <;> simp_all +decide [ SimpleGraph.contractEdgeProj_eq_vertex_iff ];
        · exact z.2 ( hv.symm );
        · exact z.2 ( hv.symm.trans ( Quotient.sound ( by tauto ) ) )
      use ⟨v, hv_ne_x, hv_ne_y⟩
      aesop

/-
If a walk maps to a path via a function that is injective on the walk's support, then the walk is a path.
-/
lemma SimpleGraph.Walk.isPath_of_map_isPath_injOn {V V' : Type*} [DecidableEq V] [DecidableEq V']
  {G : SimpleGraph V} {G' : SimpleGraph V'} (f : G →g G')
  {u v : V} (w : G.Walk u v)
  (h_inj : Set.InjOn f w.support.toFinset)
  (h_path : (w.map f).IsPath) : w.IsPath := by
    cases w <;> simp_all +decide [ SimpleGraph.Walk.IsPath ];
    rename_i p hp;
    contrapose! h_path;
    intro h_path';
    have h_support : ∀ {u v : V} {p : G.Walk u v}, (p.map f).IsPath → p.IsPath := by
      intro u v p hp; induction p <;> aesop;
    specialize @h_support _ _ hp h_path' ; aesop

/-
Definitions for the subgraphs avoiding the contraction.
-/
def SimpleGraph.avoiding_set {V : Type*} [DecidableEq V] (x y : V) : Set V := {v | v ≠ x ∧ v ≠ y}

def SimpleGraph.contractEdge_avoiding_set {V : Type*} [DecidableEq V] (x y : V) : Set (Quotient (SimpleGraph.contractEdgeSetoid x y)) := {v | v ≠ SimpleGraph.contractEdge_vertex x y}

def SimpleGraph.avoiding_subgraph {V : Type*} [DecidableEq V] (G : SimpleGraph V) (x y : V) : SimpleGraph (SimpleGraph.avoiding_set x y) :=
  G.induce (SimpleGraph.avoiding_set x y)

def SimpleGraph.contractEdge_avoiding_subgraph {V : Type*} [DecidableEq V] (G : SimpleGraph V) (x y : V) : SimpleGraph (SimpleGraph.contractEdge_avoiding_set x y) :=
  (G.contractEdge' x y).induce (SimpleGraph.contractEdge_avoiding_set x y)