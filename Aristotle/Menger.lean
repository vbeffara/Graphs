/-
We have formally proved Menger's theorem for finite simple graphs. The proof
follows the inductive argument from Diestel's Graph Theory. We first established
the weak direction (max paths ≤ min separator) as a lemma (assumed given). For
the strong direction (min separator ≤ max paths), we used strong induction on
the number of edges. The inductive step considers an edge `e = xy`. If
contracting `e` preserves the minimum separator size `k`, we lift the `k`
disjoint paths from the contracted graph. If contracting `e` reduces the minimum
separator size, we find a separator `X` of size `k` containing `x` and `y`, and
then use the induction hypothesis on `G-e` to find `k` disjoint paths from `A`
to `X` and from `X` to `B`, which are then combined. Helper lemmas were proved
to handle the properties of separators and paths under contraction and deletion.
-/

/-
This file was generated by Aristotle and then further edited by VB.
This project request had uuid: 3f0889a6-97fb-4dc9-b7e3-7271a320cd49
This project request had uuid: 7b68ab0a-0995-4676-996d-1d38e53d9b5a
This project request had uuid: 92285974-ca7c-4130-b513-da721c60ddd6
This project request had uuid: c9aae1d4-2808-455a-990f-7958bf3f6d20
This project request had uuid: d1ce6a57-e3f2-43b4-986c-6e3ff38096a8
This project request had uuid: 7abed785-bc53-494d-9616-270b30124249
This project request had uuid: 478cff34-e83f-4e23-a417-4a081de48be1
This project request had uuid: bbff98c4-ad47-4088-90fc-809d72144e14
This project request had uuid: 0b0e8333-edd1-4867-bb54-fb3dde7a2a0d
This project request had uuid: 501d12f0-c864-4306-8f63-f99f0e80f8fa
This project request had uuid: 2c55add2-c06e-41e4-aaeb-0a9fe8d399a9
This project request had uuid: af8cdac2-86a8-4c71-b303-ccb6ba9df119
-/

import Mathlib

set_option maxHeartbeats 0

open scoped Classical

variable {V : Type*} {G : SimpleGraph V} {x y u v : V} {A B X : Finset V} {n : ℕ}

namespace SimpleGraph

/-
A set of vertices S separates A from B in G if every A-B path in G contains a vertex from S.
-/
def Separates (G : SimpleGraph V) (A B : Set V) (S : Finset V) : Prop :=
  ∀ u ∈ A, ∀ v ∈ B, ∀ p : G.Walk u v, ∃ x ∈ p.support, x ∈ S

/-
The set of all vertex sets that separate A from B.
-/
def Separator (G : SimpleGraph V) (A B : Finset V) := {S : Finset V // G.Separates A B S}

/-
The set of separators is nonempty (e.g., the set of all vertices is a separator).
-/
instance Separator.nonempty (G : SimpleGraph V) (A B : Finset V) : Nonempty (G.Separator A B) :=
  ⟨A, fun u hu _ _ p => ⟨u, p.start_mem_support, hu⟩⟩

/-
An A-B path is a path in G starting in A and ending in B.
-/
structure ABPath (G : SimpleGraph V) (A B : Finset V) where
  u : A
  v : B
  walk : G.Walk u v
  isPath : walk.IsPath

/-
A set of A-B paths is disjoint if any two distinct paths in the set are vertex-disjoint.
-/
def disjointPaths (P : Finset (G.ABPath A B)) : Prop :=
  ∀ p ∈ P, ∀ q ∈ P, p ≠ q → Disjoint p.walk.support.toFinset q.walk.support.toFinset

def Joiner (G : SimpleGraph V) (A B : Finset V) := { P : Finset (G.ABPath A B) // disjointPaths P }

namespace Joiner

variable {P : G.Joiner A B}

instance : Nonempty (G.Joiner A B) := ⟨∅, by tauto⟩

theorem le_sep (P : G.Joiner A B) (S : G.Separator A B) : P.1.card ≤ S.1.card := by
  have key (p : P.1) : ∃ x : S.1, x.1 ∈ p.1.walk.support := by
    obtain ⟨x, h1, h2⟩ := S.2 p.1.u p.1.u.2 p.1.v p.1.v.2 p.1.walk
    refine ⟨⟨x, h2⟩, h1⟩
  choose f hf1 using key
  suffices f.Injective by exact Finset.card_le_card_of_injective this
  intro p q hpq
  by_contra h
  have h1 := P.2 p p.2 q q.2 (by simpa)
  simp at h1
  exact h1 (hf1 p) (hpq ▸ hf1 q)

theorem card_le (P : G.Joiner A B) : P.1.card ≤ A.card :=
  P.le_sep ⟨A, fun u hu _ _ p => ⟨u, p.start_mem_support, hu⟩⟩

end Joiner

/-
The minimum size of a separator and the maximum number of disjoint paths.
-/
noncomputable def mincut (G : SimpleGraph V) (A B : Finset V) : ℕ :=
  Nat.find (p := fun n => ∃ S : G.Separator A B, S.1.card = n)
    ⟨_, Classical.choice (Separator.nonempty G A B), rfl⟩

theorem exists_mincut (G : SimpleGraph V) (A B : Finset V) :
    ∃ S : G.Separator A B, S.1.card = G.mincut A B :=
  Nat.find_spec (p := fun n => ∃ S : G.Separator A B, S.1.card = n)
    ⟨_, Classical.choice (Separator.nonempty G A B), rfl⟩

noncomputable def maxflow (G : SimpleGraph V) (A B : Finset V) : ℕ :=
  Nat.findGreatest (fun n => ∃ P : G.Joiner A B, P.1.card = n) A.card

theorem exists_maxflow (G : SimpleGraph V) (A B : Finset V) :
    ∃ P : G.Joiner A B, P.1.card = G.maxflow A B :=
  Nat.findGreatest_spec (P := fun n => ∃ P : G.Joiner A B, P.1.card = n) (zero_le _) ⟨⟨∅, by tauto⟩, rfl⟩

/-
The maximum number of disjoint A-B paths is at most the minimum size of an A-B separator.
-/
theorem Menger_weak (G : SimpleGraph V) (A B : Finset V) : G.maxflow A B ≤ G.mincut A B := by
  obtain ⟨S, hS⟩ := exists_mincut G A B
  obtain ⟨P, hP⟩ := exists_maxflow G A B
  simpa [← hS, ← hP] using Joiner.le_sep _ _

/-
Base case of Menger's theorem: if G has no edges, the theorem holds.
-/
lemma Menger_strong_base (G : SimpleGraph V) (A B : Finset V) (h : G.edgeSet = ∅) :
  G.mincut A B ≤ G.maxflow A B := by
    simp at h ; subst G
    have h_empty : ∀ u v, (⊥ : SimpleGraph V).Walk u v → u = v := by
      intro u v p; induction p <;> aesop;
    trans (A ∩ B).card
    · simp [mincut]
      refine ⟨⟨(A ∩ B), ?_⟩, le_of_eq rfl⟩
      intro a ha b hb p
      refine ⟨a, p.start_mem_support, ?_⟩
      simp [← h_empty a b p] at hb
      simpa [ha, hb]
    · refine Nat.le_findGreatest (Finset.card_mono Finset.inter_subset_left) ?_
      let γ (a : ((A ∩ B) : Finset _)) : (⊥ : SimpleGraph V).ABPath A B :=
        ⟨⟨a, by grind⟩, ⟨a, by grind⟩ , Walk.nil, Walk.IsPath.nil⟩
      refine ⟨⟨Set.range γ |>.toFinset, ?_⟩, ?_⟩
      · intro ⟨⟨a, ha⟩, ⟨b, hb⟩, p1, hp1⟩ hp2 ⟨⟨a', ha'⟩, ⟨b', hb'⟩, p'1, hp'1⟩ hp'2 h
        cases p1 ; swap ; contradiction
        cases p'1 ; swap ; contradiction
        simp_all ; grind
      · simp
        rw [Finset.card_image_of_injective]
        · simp
        · intro a b ; simp [γ] ; tauto

/-
Definitions for edge contraction: the setoid identifying the endpoints, the
contracted graph, and the projection map.
-/
def contractEdgeSetoid (x y : V) : Setoid V :=
  Setoid.mk (fun a b => a = b ∨ (a = x ∧ b = y) ∨ (a = y ∧ b = x)) (by constructor <;> aesop)

/-
The contraction of edge (x, y) in G.
-/
def contractEdge (G : SimpleGraph V) (x y : V) : SimpleGraph (Quotient (contractEdgeSetoid x y)) :=
  let s := contractEdgeSetoid x y
  fromRel (fun a b => ∃ a' b', Quotient.mk s a' = a ∧ Quotient.mk s b' = b ∧ G.Adj a' b')

def contractEdge' (G : SimpleGraph V) (x y : V) :
    SimpleGraph (Quotient (contractEdgeSetoid x y)) :=
  fromRel (fun a b => ∃ a' b', Quotient.mk (contractEdgeSetoid x y) a' = a ∧
    Quotient.mk (contractEdgeSetoid x y) b' = b ∧ G.Adj a' b')

def contractEdgeProj (x y : V) : V → Quotient (contractEdgeSetoid x y) :=
  Quotient.mk (contractEdgeSetoid x y)

noncomputable def contractEdge_liftSet (x y : V) (S : Finset V) :
    Finset (Quotient (contractEdgeSetoid x y)) :=
  S.image (contractEdgeProj x y)

/-
Given a walk in G, there exists a walk in the contracted graph G/e between the
projected endpoints, whose support is contained in the image of the original
walk's support.
-/
lemma exists_walk_of_path_contraction (G : SimpleGraph V) (x y : V) (p : G.Walk u v) :
    ∃ (w : (G.contractEdge' x y).Walk (contractEdgeProj x y u) (contractEdgeProj x y v)),
    w.support.toFinset ⊆ p.support.toFinset.image (contractEdgeProj x y) := by
  induction' p with u v p ih;
  · exact ⟨Walk.nil, by simp⟩;
  · simp +zetaDelta at *;
    cases' ‹∃ w, _› with w hw;
    by_cases h : contractEdgeProj x y v = contractEdgeProj x y p;
    · grind;
    · have h_adj : (G.contractEdge' x y).Adj (contractEdgeProj x y v) (contractEdgeProj x y p) := by
        unfold contractEdge';
        aesop;
      refine' ⟨ Walk.cons h_adj w, _ ⟩;
      simp_all [ Finset.subset_iff ]

/-
The preimage of a set of vertices in the contracted graph.
-/
noncomputable def contractEdge_preimage [Fintype V] (x y : V)
    (Y : Finset (Quotient (contractEdgeSetoid x y))) : Finset V :=
  Finset.univ.filter (fun v => contractEdgeProj x y v ∈ Y)

/-
If a set of vertices separates A and B in the contracted graph G/e, then its preimage separates A and B in G.
-/
lemma contractEdge_preimage_separates [Fintype V]
    (Y : (G.contractEdge' x y).Separator (contractEdge_liftSet x y A) (contractEdge_liftSet x y B)) :
  G.Separates A B (contractEdge_preimage x y Y.1) := by
    intro u hu v hv p
    obtain ⟨ w, hw ⟩ := exists_walk_of_path_contraction G x y p;
    -- Since $w$ is a path in the contracted graph from $\pi(u)$ to $\pi(v)$, and $Y$ separates $\pi(A)$ and $\pi(B)$ in the contracted graph, $w$ must intersect $Y$.
    obtain ⟨ z, hzY, hzw ⟩ : ∃ z ∈ Y.1, z ∈ w.support := by
      have := Y.2 (contractEdgeProj x y u)
        (by exact Finset.mem_image_of_mem _ hu)
        (contractEdgeProj x y v)
        (by exact Finset.mem_image_of_mem _ hv)
        w.toPath;
      exact this |> fun ⟨z, hz₁, hz₂ ⟩ => ⟨ z, hz₂, by simpa using Walk.support_bypass_subset _ hz₁ ⟩;
    have := hw ( by simpa using hzw );
    simp +zetaDelta at *;
    exact ⟨ this.choose, this.choose_spec.1, Finset.mem_filter.mpr ⟨ Finset.mem_univ _, this.choose_spec.2.symm ▸ hzY ⟩ ⟩

/-
The contracted vertex in the quotient graph.
-/
def contractEdge_vertex (x y : V) : Quotient (contractEdgeSetoid x y) :=
  Quotient.mk (contractEdgeSetoid x y) x

lemma contractEdge_vertex_eq (x y : V) :
  contractEdge_vertex x y = Quotient.mk (contractEdgeSetoid x y) y := by
  apply Quotient.sound
  right ; grind

/-
A vertex projects to the contracted vertex if and only if it is one of the endpoints of the contracted edge.
-/
lemma contractEdgeProj_eq_vertex_iff (x y u : V) :
    contractEdgeProj x y u = contractEdgeProj x y x ↔ u = x ∨ u = y := by
  simp [contractEdgeProj, contractEdgeSetoid, Quotient.eq]
  grind

/-
The projection map is injective on vertices that do not map to the contracted vertex.
-/
lemma contractEdgeProj_inj_on (x y : V) (u v : V)
    (hu : contractEdgeProj x y u ≠ contractEdge_vertex x y)
    (hv : contractEdgeProj x y v ≠ contractEdge_vertex x y)
    (h_eq : contractEdgeProj x y u = contractEdgeProj x y v) : u = v := by
  have h_equiv : u = v ∨ (u = x ∧ v = y) ∨ (u = y ∧ v = x) := by
    erw [ Quotient.eq ] at h_eq ; aesop;
  tauto

/-
If the projections of two vertices are adjacent in the contracted graph and neither projects to the contracted vertex, then the original vertices are adjacent in the original graph.
-/
lemma contractEdge_adj_lift (G : SimpleGraph V) (x y : V) (u v : V)
  (hu : contractEdgeProj x y u ≠ contractEdge_vertex x y)
  (hv : contractEdgeProj x y v ≠ contractEdge_vertex x y) :
  (G.contractEdge' x y).Adj (contractEdgeProj x y u) (contractEdgeProj x y v) → G.Adj u v := by
    rintro ⟨ a, b, ha, hb, hab ⟩;
    · unfold contractEdgeProj at *;
      unfold contractEdge_vertex at *; simp_all [ Quotient.eq ] ;
      unfold contractEdgeSetoid at *; aesop;
    · -- Apply the lemma that states if the projections of two vertices are adjacent and neither is the contracted vertex, then the original vertices are adjacent.
      have h_adj : contractEdgeProj x y v ≠ contractEdge_vertex x y → contractEdgeProj x y u ≠ contractEdge_vertex x y → (G.contractEdge' x y).Adj (contractEdgeProj x y v) (contractEdgeProj x y u) → G.Adj v u := by
        unfold contractEdgeProj at *;
        unfold contractEdge_vertex at *; simp_all [ Quotient.eq ] ;
        unfold contractEdgeSetoid at *; aesop;
      simp_all [ adj_comm ];
      unfold contractEdge' at *; aesop;

/-
The size of the preimage of a set of vertices in the contracted graph.
-/
lemma card_preimage_contractEdge [Fintype V] (h : x ≠ y) (Y) : (contractEdge_preimage x y Y).card =
    if contractEdge_vertex x y ∈ Y then Y.card + 1 else Y.card := by
  -- Let's count the number of elements in the preimage of Y.
  have h_card_preimage : (Finset.univ.filter (fun v => contractEdgeProj x y v ∈ Y)).card =
      ∑ z ∈ Y, (Finset.univ.filter (fun v => contractEdgeProj x y v = z)).card := by
    simp only [Finset.card_filter];
    rw [Finset.sum_comm, Finset.sum_congr rfl]
    simp
  -- Let's count the number of elements in each fiber of the projection map.
  have h_fiber_card : ∀ z ∈ Y, (Finset.univ.filter (fun v => contractEdgeProj x y v = z)).card =
      if z = contractEdge_vertex x y then 2 else 1 := by
    intro z hz
    by_cases hz_eq : z = contractEdge_vertex x y;
    · simp [hz_eq];
      rw [ Finset.card_eq_two ];
      refine' ⟨ x, y, h, _ ⟩;
      ext v; simp [contractEdgeProj, contractEdge_vertex];
      simp [Quotient.eq, contractEdgeSetoid]; grind
    · obtain ⟨ v, rfl ⟩ := Quotient.exists_rep z;
      simp [ contractEdgeProj, contractEdge_vertex ];
      split_ifs with h';
      · simp [Quotient.eq, contractEdgeSetoid, Finset.card_eq_two] at h' ⊢
        refine ⟨x, y, h, ?_⟩
        grind
      · rw [ Finset.card_eq_one ];
        use v
        simp [Quotient.eq, contractEdgeSetoid] at h' ⊢
        grind
  split_ifs <;> simp_all [Finset.sum_ite, contractEdge_preimage];
  · simp_all [ Finset.filter_eq', Finset.filter_ne' ];
    linarith [ Nat.sub_add_cancel ( show 1 ≤ Y.card from Finset.card_pos.mpr ⟨ _, ‹_› ⟩ ) ];
  · simp_all [ Finset.filter_eq', Finset.filter_ne' ]

/-
A walk in the contracted graph that avoids the contracted vertex can be lifted to a walk in the original graph.
-/
lemma lift_walk_avoiding_contraction {u v : Quotient (contractEdgeSetoid x y)}
    (p : (G.contractEdge' x y).Walk u v) (hp : contractEdge_vertex x y ∉ p.support) :
  ∃ (u' v' : V) (q : G.Walk u' v'), contractEdgeProj x y u' = u ∧ contractEdgeProj x y v' = v ∧
    (q.support.toFinset.image (contractEdgeProj x y)) = p.support.toFinset ∧
    x ∉ q.support ∧ y ∉ q.support := by
  induction' p with u v p ih;
  · obtain ⟨ u', rfl ⟩ := Quotient.exists_rep u;
    by_cases hu : u' = x ∨ u' = y;
    · cases hu <;> simp_all [ Quotient.eq, contractEdge_vertex, contractEdgeSetoid ];
    · refine' ⟨ u', u', Walk.nil, _, _, _, _ ⟩ <;> simp_all [ contractEdgeProj ];
      tauto;
  · rename_i h₁ h₂;
    -- Since v is not the contracted vertex, there exists a unique u' in V such that contractEdgeProj x y u' = v.
    obtain ⟨u', hu'⟩ : ∃ u' : V, contractEdgeProj x y u' = v ∧ u' ≠ x ∧ u' ≠ y := by
      rcases Quotient.exists_rep v with ⟨ u', rfl ⟩;
      refine' ⟨ u', rfl, _, _ ⟩ <;> contrapose! hp <;> simp_all [ contractEdge_vertex ];
      exact Or.inl ( by simp [Quotient.eq, contractEdgeSetoid] );
    obtain ⟨ v', hv' ⟩ := h₂ ( by intro h; simp_all [ Walk.support_cons ] );
    obtain ⟨ v'', q, hv'', hv''', hq, hx, hy ⟩ := hv';
    refine' ⟨ u', v'', Walk.cons _ q, hu'.1, hv''', _, _, _ ⟩ <;> simp_all [ Walk.support_cons ];
    · have h_adj : (G.contractEdge' x y).Adj (contractEdgeProj x y u') (contractEdgeProj x y v') := by
        grind;
      apply contractEdge_adj_lift G x y u' v';
      · grind;
      · intro h; simp_all
      · exact h_adj;
    · tauto;
    · grind

/-
Define deleting a single edge and prove it reduces edge count if the edge exists.
-/
def deleteEdge (G : SimpleGraph V) (x y : V) : SimpleGraph V :=
  G.deleteEdges {Sym2.mk (x, y)}

lemma deleteEdge_card_edges_lt [Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj] (x y : V) (h : G.Adj x y) :
  (G.deleteEdge x y).edgeFinset.card < G.edgeFinset.card := by
    refine' Finset.card_lt_card _;
    simp [deleteEdge, h]

/- =========================== REVIEW BAR ===================== -/

end SimpleGraph
-- #exit

/-
A path in the contracted graph avoiding the contracted vertex lifts to a path in the original graph avoiding the contracted edge's endpoints (subset support).
-/
lemma SimpleGraph.lift_path_avoiding_contraction_AB (G : SimpleGraph V) (A B : Finset V) (x y : V)
    {u v : Quotient (SimpleGraph.contractEdgeSetoid x y)} (p : (G.contractEdge' x y).Walk u v)
    (hp_avoid : SimpleGraph.contractEdge_vertex x y ∉ p.support)
    (hu : u ∈ SimpleGraph.contractEdge_liftSet x y A) (hv : v ∈ SimpleGraph.contractEdge_liftSet x y B) :
  ∃ (u' v' : V) (q : G.Walk u' v'), u' ∈ A ∧ v' ∈ B ∧
    SimpleGraph.contractEdgeProj x y u' = u ∧ SimpleGraph.contractEdgeProj x y v' = v ∧ q.IsPath ∧
    (q.support.toFinset.image (SimpleGraph.contractEdgeProj x y)) ⊆ p.support.toFinset ∧
    x ∉ q.support ∧ y ∉ q.support := by
  have := @SimpleGraph.lift_walk_avoiding_contraction V G x y u v p hp_avoid;
  obtain ⟨ u', v', q, hu', hv', hq ⟩ := this;
  refine' ⟨ u', v', q.toPath, _, _, hu', hv', _, _, _ ⟩
  · simp [contractEdge_liftSet] at hu
    obtain ⟨ w, hw, rfl ⟩ := hu;
    cases h1 : eq_or_ne u' x <;> cases h2 : eq_or_ne u' y <;> cases h3 : eq_or_ne w x <;> cases h4 : eq_or_ne w y
    all_goals subst_eqs
    all_goals simp_all [ SimpleGraph.contractEdgeProj, Quotient.eq, contractEdgeSetoid ];
  · simp [contractEdge_liftSet] at hv
    obtain ⟨ w, hw ⟩ := hv;
    have h_inj : ∀ a b : V, SimpleGraph.contractEdgeProj x y a = SimpleGraph.contractEdgeProj x y b → a = b ∨ a = x ∧ b = y ∨ a = y ∧ b = x := by
      intro a b hab; erw [ Quotient.eq ] at hab; aesop;
    cases h_inj _ _ ( hv'.trans hw.2.symm ) <;> aesop;
  · simp_all [ SimpleGraph.Walk.isPath_def ];
  · rw [ ← hq.1 ];
    simp [ Finset.subset_iff ];
    intro a ha;
    exact ⟨ a, by simpa using SimpleGraph.Walk.support_toPath_subset q ha, rfl ⟩;
  · exact ⟨ fun h => hq.2.1 <| by simpa using q.support_bypass_subset h, fun h => hq.2.2 <| by simpa using q.support_bypass_subset h ⟩

/-
If a vertex is adjacent to the contracted vertex in the quotient graph, then it is adjacent to one of the endpoints of the contracted edge in the original graph.
-/
lemma SimpleGraph.contractEdge_adj_lift_vertex (G : SimpleGraph V) (x y : V) (u : V)
  (hu : SimpleGraph.contractEdgeProj x y u ≠ SimpleGraph.contractEdge_vertex x y) :
  (G.contractEdge' x y).Adj (SimpleGraph.contractEdgeProj x y u) (SimpleGraph.contractEdge_vertex x y) → G.Adj u x ∨ G.Adj u y := by
    rintro ⟨ a, ha ⟩;
    rcases ha with ( ⟨ a', b', ha', hb', hab ⟩ | ⟨ a', b', ha', hb', hab ⟩ );
    · simp_all [ Quotient.eq, contractEdgeProj, contractEdge_vertex ];
      unfold contractEdgeSetoid at *; aesop;
    · rw [ eq_comm ] at ha' hb';
      cases eq_or_ne a' x <;> cases eq_or_ne a' y <;> cases eq_or_ne b' x <;> cases eq_or_ne b' y
      all_goals simp_all [ SimpleGraph.contractEdge_vertex, SimpleGraph.contractEdgeProj,
        Quotient.eq, contractEdgeSetoid, SimpleGraph.adj_comm ];

/-
The number of edges in the contracted graph is strictly less than in the original graph.
-/
lemma SimpleGraph.contractEdge_edge_card_lt [Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj] (x y : V) (h : G.Adj x y) :
  (G.contractEdge' x y).edgeFinset.card < G.edgeFinset.card := by
    have h_inter : Finset.card (G.contractEdge' x y).edgeFinset ≤ Finset.card (G.edgeFinset \ {Sym2.mk (x, y)}) := by
      have h_inter : (G.contractEdge' x y).edgeFinset ⊆ Finset.image (fun e => Sym2.map (SimpleGraph.contractEdgeProj x y) e) (G.edgeFinset \ {Sym2.mk (x, y)}) := by
        intro e he; simp_all [ SimpleGraph.contractEdge' ] ;
        rcases e with ⟨ a, b ⟩ ; simp_all [ fromRel ] ;
        rcases he.2 with ( ⟨ a', rfl, b', rfl, hab ⟩ | ⟨ a', rfl, b', rfl, hab ⟩ ) <;> use Sym2.mk ( a', b' ) <;> simp_all [ Sym2.eq_swap ];
        · simp_all [Quotient.eq, contractEdgeSetoid] ; aesop
        · simp_all [Quotient.eq, contractEdgeSetoid] ; aesop
      exact le_trans ( Finset.card_le_card h_inter ) ( Finset.card_image_le );
    exact lt_of_le_of_lt h_inter ( Finset.card_lt_card ( Finset.ssubset_iff_subset_ne.mpr ⟨ Finset.sdiff_subset, by aesop ⟩ ) )

/-
If a walk's support intersects {x, y} only at v (or not at all), then the walk does not use the edge xy.
-/
lemma SimpleGraph.Walk.edges_no_xy_of_support_inter_subset_one {G : SimpleGraph V}
  {u v : V} (p : G.Walk u v) (x y : V) (hxy : x ≠ y)
  (h : p.support.toFinset ∩ {x, y} ⊆ {v}) :
  Sym2.mk (x, y) ∉ p.edges := by
    contrapose! h;
    simp_all [ Finset.eq_singleton_iff_unique_mem ];
    -- If the edge {x, y} is in the walk's edges, then both x and y must be in the walk's support.
    have h_support : x ∈ p.support ∧ y ∈ p.support := by
      induction p <;> aesop;
    aesop

/-
If a walk intersects X, there is a prefix walk ending in X that avoids X internally.
-/
lemma SimpleGraph.Walk.exists_walk_prefix_avoiding_set {G : SimpleGraph V} {u v : V} (p : G.Walk u v) (X : Set V) (h : ∃ w ∈ p.support, w ∈ X) :
  ∃ (w : V) (q : G.Walk u w), w ∈ X ∧ q.support.toFinset ⊆ p.support.toFinset ∧ (∀ z ∈ q.support, z ∈ X → z = w) := by
    revert h p;
    -- We'll use induction on the length of the walk.
    intro p hp
    induction' p with u v p ih;
    · simp_all [ SimpleGraph.Walk.support ];
      exact ⟨ u, hp, SimpleGraph.Walk.nil, by simp ⟩;
    · rename_i h₁ h₂ h₃;
      by_cases h : v ∈ X;
      · refine' ⟨ v, SimpleGraph.Walk.nil, h, _, _ ⟩ <;> simp [ h ];
      · rcases h₃ ( by cases hp; aesop ) with ⟨ w, q, hw, hq₁, hq₂ ⟩ ; use w, cons h₁ q ; aesop;

/-
If a path intersects X, there is a prefix path ending in X that avoids X internally.
-/
lemma SimpleGraph.Walk.exists_path_prefix_avoiding_set {G : SimpleGraph V} {u v : V} (p : G.Walk u v)
    (X : Set V) (h : ∃ w ∈ p.support, w ∈ X) :
    ∃ (w : V) (q : G.Walk u w), w ∈ X ∧ q.IsPath ∧ q.support.toFinset ⊆ p.support.toFinset ∧ (∀ z ∈ q.support, z ∈ X → z = w) := by
    obtain ⟨ w, hw₁, hw₂ ⟩ := h;
    obtain ⟨ q, hq₁, hq₂ ⟩ := p.exists_walk_prefix_avoiding_set X ⟨ w, hw₁, hw₂ ⟩;
    refine' ⟨ q, hq₁.toPath, hq₂.1, _, _, _ ⟩
    · simp
    · refine subset_trans ?_ hq₂.2.1
      simp [toPath, Finset.subset_iff]
      exact fun x hx => SimpleGraph.Walk.support_bypass_subset hq₁ hx
    · intro z hz hzX; specialize hq₂; have := hq₂.2.2 z; simp_all
      exact hq₂.2.2 z ( by simpa using hq₁.support_bypass_subset hz ) hzX

/-
If X separates A and B in G and contains x and y, then any separator of A and X in G-xy is also a separator of A and B in G.
-/
lemma SimpleGraph.separator_in_G_of_separator_in_G_delete_edge (G : SimpleGraph V) (A B : Finset V)
    (x y : V) (X : G.Separator A B) (S : (G.deleteEdge x y).Separator A X.1) (hx : x ∈ X.1) (hy : y ∈ X.1)
    (hxy : x ≠ y) : G.Separates A B S.1 := by
    -- Let P be an A-B path in G.
    classical
    intro u hu v hv p
    obtain ⟨w, q, hwX, hqpath, hq_support, hq_avoid⟩ : ∃ (w : V) (q : G.Walk u w), w ∈ X.1 ∧ q.IsPath ∧ q.support.toFinset ⊆ p.support.toFinset ∧ (∀ z ∈ q.support, z ∈ X.1 → z = w) := by
      have := X.2 u hu v hv p.bypass
      obtain ⟨w, q, h1, h2, h3, h4⟩ := SimpleGraph.Walk.exists_path_prefix_avoiding_set p.bypass X.1 this
      refine ⟨w, q, h1, h2, h3.trans ?_, h4⟩
      have := p.support_bypass_subset
      intro x hx
      simp at hx
      specialize this hx
      simpa

    -- Since x, y ∈ X, q avoids {x, y} internally.
    have hq_avoid_xy : Sym2.mk (x, y) ∉ q.edges := by
      apply SimpleGraph.Walk.edges_no_xy_of_support_inter_subset_one q x y hxy;
      intro z hz; specialize hq_avoid z; aesop;
    -- Since q is a path in G-xy, it follows that q is a path in G-xy.
    have hq_path_G_minus_xy : ∃ q' : (G.deleteEdge x y).Walk u w, q'.IsPath ∧ q'.support.toFinset ⊆ q.support.toFinset := by
      have hq_path_G_minus_xy : ∀ {u v : V} (q : G.Walk u v), q.IsPath → Sym2.mk (x, y) ∉ q.edges → ∃ q' : (G.deleteEdge x y).Walk u v, q'.IsPath ∧ q'.support.toFinset ⊆ q.support.toFinset := by
        intro u v q hq hq_avoid_xy
        induction' q with u v q ih;
        · exact ⟨ SimpleGraph.Walk.nil, by simp ⟩;
        · rename_i h₁ h₂ h₃;
          simp_all [ SimpleGraph.Walk.cons_isPath_iff ];
          obtain ⟨ q', hq'_path, hq'_support ⟩ := h₃;
          refine' ⟨ SimpleGraph.Walk.cons _ q', _, _ ⟩ <;> simp_all [ Finset.subset_iff ];
          · unfold SimpleGraph.deleteEdge; aesop;
          · exact fun h => hq.2 ( by simpa using hq'_support ( by simpa using h ) );
          · intro a ha; specialize hq'_support ( List.mem_toFinset.mpr ha ) ; aesop;
      exact hq_path_G_minus_xy q hqpath hq_avoid_xy;
    obtain ⟨ q', hq'_path, hq'_support ⟩ := hq_path_G_minus_xy;
    have := S.2 u hu w hwX q';  simp_all [ SimpleGraph.Walk.isPath_def ] ;
    obtain ⟨ z, hz₁, hz₂ ⟩ := this; exact ⟨ z, by simpa using hq'_support ( by simpa using hz₁ ) |> fun h => hq_support h, hz₂ ⟩ ;

/-
If a separator in the contracted graph has size strictly less than the minimum separator size of the original graph, then it must contain the contracted vertex.
-/
theorem SimpleGraph.contractEdge_separator_contains_vertex [Fintype V] (G : SimpleGraph V) (A B : Finset V) (x y : V) (k : ℕ)
  (h_min : G.mincut A B = k)
  (Y : (G.contractEdge' x y).Separator (SimpleGraph.contractEdge_liftSet x y A) (SimpleGraph.contractEdge_liftSet x y B))
  (hY_card : Y.1.card < k)
  (hxy : x ≠ y) :
  SimpleGraph.contractEdge_vertex x y ∈ Y.1 := by
    contrapose! hY_card;
    rw [ ← h_min ];
    simp [SimpleGraph.mincut]
    refine ⟨⟨SimpleGraph.contractEdge_preimage x y Y.1, ?_⟩, ?_⟩
    · exact contractEdge_preimage_separates Y
    · simp [card_preimage_contractEdge hxy Y.1, hY_card]

/-
If P is a set of disjoint paths from A to X with size equal to X, then every vertex in X is the endpoint of exactly one path in P, and that path intersects X only at its endpoint.
-/
lemma SimpleGraph.disjoint_paths_prop (G : SimpleGraph V) (A X : Finset V)
    (P : G.Joiner A X) (hP_card : P.1.card = X.card) :
  ∀ x ∈ X, ∃! p ∈ P.1, p.v = x ∧ p.walk.support.toFinset ∩ X = {x} := by
    -- Since $P$ consists of disjoint paths, the endpoints in $X$ must be distinct. Thus, the map $p \mapsto p.v$ is injective from $P$ to $X$.
    have h_inj : Set.InjOn (fun p : G.ABPath A X => p.v.1) P.1 := by
      intro p hp q hq h_eq;
      have := P.2 p hp q hq; simp_all [ Finset.disjoint_left ] ;
      contrapose! this;
      exact ⟨ this, p.v, by simp, by simp [ h_eq ] ⟩;
    -- Since $|P| = |X|$, this map is a bijection.
    have h_bij : Set.BijOn (fun p : G.ABPath A X => p.v.1) P.1 X := by
      refine' ⟨ _, _, _ ⟩;
      · exact fun p hp => by simp
      · exact h_inj;
      · have h_surj : Finset.image (fun p : G.ABPath A X => p.v.1) P.1 = X := by
          refine' Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr _ ) _;
          · exact fun p hp => p.v.2
          · rw [ Finset.card_image_of_injOn h_inj, hP_card ];
        intro x hx; replace h_surj := Finset.ext_iff.mp h_surj x; aesop;
    intro x hx
    obtain ⟨p, hp⟩ : ∃ p ∈ P.1, p.v = x := by
      exact h_bij.surjOn ( by simpa );
    -- If $z \in p.support \cap X$ and $z \ne x$, then there exists some $q \in P$ with $q.v = z$.
    by_contra h_contra
    obtain ⟨z, hzP, hzX, hzne⟩ : ∃ z ∈ p.walk.support, z ∈ X ∧ z ≠ x := by
      contrapose! h_contra; use p; aesop;
    obtain ⟨ q, hqP, hqz ⟩ : ∃ q ∈ P.1, q.v = z := by
      have := h_bij.surjOn ( show z ∈ X from by simpa using hzX ) ; aesop;
    have := P.2 p hp.1 q hqP; simp_all [ Finset.disjoint_left ] ;
    exact this ( by rintro rfl; exact hzne ( by aesop ) ) hzP ( by aesop )

/-
If an A-X path intersects X only at its endpoint, then any prefix ending at a vertex not in X avoids X entirely.
-/
lemma SimpleGraph.ABPath_prefix_avoids_X (G : SimpleGraph V) (A X : Finset V) (X_fin : Finset V)
  (p : G.ABPath A X)
  (hp_X : p.walk.support.toFinset ∩ X_fin = {p.v.1})
  (z : V)
  (hz : z ∈ p.walk.support)
  (hzX : z ∉ X_fin) :
  (p.walk.takeUntil z hz).support.toFinset ∩ X_fin = ∅ := by
    simp_all [ Finset.ext_iff ];
    intro a ha haX;
    have ha_support : a ∈ p.walk.support := by
      have h_support_subset : (p.walk.takeUntil z hz).support ⊆ p.walk.support := by
        exact Walk.support_takeUntil_subset p.walk hz;
      exact h_support_subset ha;
    have := hp_X a; simp_all ;
    have := p.isPath;
    have := SimpleGraph.Walk.endpoint_notMem_support_takeUntil this hz; simp_all ;

/-
If a walk is a path, and we drop the prefix until a vertex w (where w is not the start), then the start vertex is not in the remaining suffix.
-/
lemma SimpleGraph.Walk.start_notMem_support_dropUntil {G : SimpleGraph V}
  {u v w : V} {p : G.Walk u v} (hp : p.IsPath) (hw : w ∈ p.support) (h : u ≠ w) :
  u ∉ (p.dropUntil w hw).support := by
    -- Since $p$ is a path, it has no repeated vertices. Therefore, $u$ cannot be in the support of $p.dropUntil w hw$.
    have h_no_repeat : ∀ v ∈ p.support, v = u → v ∉ (p.dropUntil w hw).support := by
      have h_support : ∀ v ∈ p.support, v = u → v ∉ (p.dropUntil w hw).support := by
        intro v hv hvu
        have h_lift : ∀ w' ∈ p.support, w' ∉ (p.dropUntil w hw).support → w' = u → v ∉ (p.dropUntil w hw).support := by
          aesop
        exact h_lift u ( by simp ) ( by
          induction p <;> simp_all [ SimpleGraph.Walk.dropUntil ];
          · cases hw;
            · contradiction;
            · contradiction;
          · exact fun h => hp.2 ( SimpleGraph.Walk.support_dropUntil_subset _ _ h ) ) rfl;
      exact h_support;
    exact h_no_repeat u ( p.start_mem_support ) rfl

/-
If an X-B path intersects X only at its start point, then any suffix starting at a vertex not in X avoids X entirely.
-/
lemma SimpleGraph.ABPath_suffix_avoids_X (G : SimpleGraph V) (B X : Finset V) (X_fin : Finset V)
  (q : G.ABPath X B)
  (hq_X : q.walk.support.toFinset ∩ X_fin = {q.u.1})
  (z : V)
  (hz : z ∈ q.walk.support)
  (hzX : z ∉ X_fin) :
  (q.walk.dropUntil z hz).support.toFinset ∩ X_fin = ∅ := by
    rw [ Finset.eq_empty_iff_forall_notMem ];
    intro x hx
    have hx_suff : x ≠ q.u := by
      intro hx_eq_q_u;
      have := q.walk.start_notMem_support_dropUntil q.isPath hz; simp_all ;
    simp_all [ Finset.ext_iff ];
    have := hq_X x; simp_all
    exact this ( q.walk.support_dropUntil_subset hz hx.1 )

/-
If X separates A and B, and p is an A-X path hitting X only at the end, and q is an X-B path hitting X only at the start, then p and q intersect only at their common endpoint in X (if any).
-/
lemma SimpleGraph.path_intersection_of_separator (X : G.Separator A B) (p : G.ABPath A X.1)
    (q : G.ABPath X.1 B) (hp_X : p.walk.support.toFinset ∩ X.1 = {p.v.1})
    (hq_X : q.walk.support.toFinset ∩ X.1 = {q.u.1}) :
    p.walk.support.toFinset ∩ q.walk.support.toFinset ⊆ {p.v.1} ∩ {q.u.1} := by
  intro x hx;
  by_cases hxX : x ∈ X.1 <;> simp_all [ Finset.ext_iff ];
  · exact ⟨ hp_X x |>.1 ⟨ hx.1, hxX ⟩, hq_X x |>.1 ⟨ hx.2, hxX ⟩ ⟩;
  · -- Since $x \notin X$, we can construct a walk from $A$ to $B$ avoiding $X$.
    obtain ⟨w1, hw1⟩ : ∃ w1 : G.Walk p.u x, w1.support.toFinset ∩ X.1 = ∅ := by
      use p.walk.takeUntil x hx.1;
      apply SimpleGraph.ABPath_prefix_avoids_X;
      · ext; aesop;
      · exact hxX
    obtain ⟨w2, hw2⟩ : ∃ w2 : G.Walk x q.v, w2.support.toFinset ∩ X.1 = ∅ := by
      use q.walk.dropUntil x hx.2;
      rw [ SimpleGraph.ABPath_suffix_avoids_X ] <;> aesop
    have hw : ∃ w : G.Walk p.u q.v, w.support.toFinset ∩ X.1 = ∅ := by
      use w1.append w2;
      simp_all [ Finset.ext_iff ];
      rintro a ( ha | ha ) <;> tauto;
    have hX_sep := X.2 ; contrapose! hX_sep
    obtain ⟨ w, hw ⟩ := hw;
    simp_all [ SimpleGraph.Separates ];
    refine' ⟨ p.u, p.u.2, q.v, q.v.2, w, _ ⟩
    simp_all [ Finset.ext_iff ];

/-
If P is a set of disjoint paths from X to B with size equal to X, then every vertex in X is the start of exactly one path in P, and that path intersects X only at its start.
-/
lemma SimpleGraph.disjoint_paths_prop_start (G : SimpleGraph V) (X B : Finset V)
    (P : G.Joiner X B) (hP_card : P.1.card = X.card) :
  ∀ x ∈ X, ∃! p ∈ P.1, p.u = x ∧ p.walk.support.toFinset ∩ X = {x} := by
    -- Since $P$ consists of disjoint paths starting in $X$, the start points in $X$ must be distinct.
    have h_distinct_start : ∀ p q : G.ABPath X B, p ∈ P.1 → q ∈ P.1 → p ≠ q → p.u.1 ≠ q.u.1 := by
      intro p q hp hq hpq h; have := P.2 p hp q hq; simp_all
      exact this ( p.walk.start_mem_support ) ( by simp [ h ] );
    -- Since $P$ consists of disjoint paths starting in $X$, the start points in $X$ must be distinct, and thus each $x \in X$ is the start point of exactly one path in $P$.
    have h_unique_start : ∀ x ∈ X, ∃ p ∈ P.1, p.u = x := by
      have h_unique_start : Finset.image (fun p : G.ABPath X B => p.u.1) P.1 = X := by
        refine' Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr _ ) _;
        · exact fun p hp => p.u.2;
        · rw [ Finset.card_image_of_injOn fun p hp q hq hpq => by contrapose! hpq; exact h_distinct_start p q hp hq hpq, hP_card ];
      intro x hx; replace h_unique_start := Finset.ext_iff.mp h_unique_start x; aesop;
    -- For any $x \in X$, since $p$ is a path from $X$ to $B$ starting at $x$, the only element in $X$ that $p$ can intersect is $x$ itself.
    have h_path_intersects_X_only_at_start : ∀ x ∈ X, ∀ p ∈ P.1, p.u = x → p.walk.support.toFinset ∩ X = {x} := by
      intro x hx p hp hp_start
      have h_path_intersects_X_only_at_start : ∀ z ∈ p.walk.support, z ∈ X → z = x := by
        intro z hz hzX
        by_contra h_contra;
        obtain ⟨ q, hq, hq_start ⟩ := h_unique_start z ( by simpa using hzX );
        have := P.2 p hp q hq ; simp_all [ Finset.disjoint_left ];
        exact this ( by rintro rfl; exact h_contra ( by aesop ) ) hz ( by aesop );
      ext z; specialize h_path_intersects_X_only_at_start z; aesop;
    exact fun x hx => by obtain ⟨ p, hp₁, hp₂ ⟩ := h_unique_start x hx; exact ⟨ p, ⟨ hp₁, hp₂, h_path_intersects_X_only_at_start x hx p hp₁ hp₂ ⟩, fun q hq => Classical.not_not.1 fun hq' => h_distinct_start q p hq.1 hp₁ hq' <| by aesop ⟩ ;

/-
If p and q are paths that intersect only at the join point, their concatenation is a path.
-/
lemma SimpleGraph.Walk.IsPath_append_of_support_inter_subset_one {G : SimpleGraph V}
  {u v w : V} (p : G.Walk u v) (q : G.Walk v w)
  (hp : p.IsPath) (hq : q.IsPath)
  (h_inter : p.support.toFinset ∩ q.support.toFinset ⊆ {v}) :
  (p.append q).IsPath := by
    have hpq_distinct : ∀ x ∈ p.support, x ≠ v → x ∉ q.support := by
      intro x hx hxv hxq; specialize h_inter ( Finset.mem_inter_of_mem ( List.mem_toFinset.mpr hx ) ( List.mem_toFinset.mpr hxq ) ) ; aesop;
    cases p <;> cases q <;> simp_all [ SimpleGraph.Walk.isPath_def ];
    simp_all [ SimpleGraph.Walk.support_append ];
    rw [ List.nodup_append ] ; aesop

/-
If p is an A-X path ending at x, and q is an X-B path starting at x, and both intersect X only at x, then their concatenation is a path.
-/
lemma SimpleGraph.joined_path_is_path (G : SimpleGraph V) (A B : Finset V) (X : Finset V)
  (hX_sep : G.Separates A B X)
  (x : V)
  (p : G.ABPath A X) (h_p : p.v = x) (h_p_X : p.walk.support.toFinset ∩ X = {x})
  (q : G.ABPath X B) (h_q : q.u = x) (h_q_X : q.walk.support.toFinset ∩ X = {x}) :
  ((p.walk.copy rfl h_p).append (q.walk.copy h_q rfl)).IsPath := by
    -- Since the intersection of the supports of p and q is {x}, their concatenation is a path.
    have h_support_union : (p.walk.copy rfl h_p).support.toFinset ∩ (q.walk.copy h_q rfl).support.toFinset ⊆ {x} := by
      convert path_intersection_of_separator ⟨X, hX_sep⟩ _ _ _ _ using 2 <;> aesop;
    apply_rules [ SimpleGraph.Walk.IsPath_append_of_support_inter_subset_one ];
    · cases p ; aesop;
    · cases q ; aesop

/-
If we have two pairs of paths (px, qx) and (py, qy) meeting at x and y respectively, and the pairs are disjoint from each other, and cross-intersections are empty due to separation, then the joined paths are disjoint.
-/
lemma SimpleGraph.joined_paths_disjoint (G : SimpleGraph V) (A B : Finset V) (X : Finset V)
  (hX_sep : G.Separates A B X)
  (x y : V) (hxy : x ≠ y)
  (px : G.ABPath A X) (hpx : px.v = x) (hpx_X : px.walk.support.toFinset ∩ X = {x})
  (py : G.ABPath A X) (hpy : py.v = y) (hpy_X : py.walk.support.toFinset ∩ X = {y})
  (qx : G.ABPath X B) (hqx : qx.u = x) (hqx_X : qx.walk.support.toFinset ∩ X = {x})
  (qy : G.ABPath X B) (hqy : qy.u = y) (hqy_X : qy.walk.support.toFinset ∩ X = {y})
  (hp_disj : Disjoint px.walk.support.toFinset py.walk.support.toFinset)
  (hq_disj : Disjoint qx.walk.support.toFinset qy.walk.support.toFinset) :
  Disjoint (px.walk.support.toFinset ∪ qx.walk.support.toFinset) (py.walk.support.toFinset ∪ qy.walk.support.toFinset) := by
    norm_num +zetaDelta at *;
    have hpqx : ∀ w ∈ px.walk.support, w ∉ qy.walk.support := by
      have := path_intersection_of_separator ⟨X, hX_sep⟩ px qy; simp_all [ Finset.ext_iff ] ;
    have hqypx : ∀ w ∈ qx.walk.support, w ∉ py.walk.support := by
      intro w hw hw';
      have := SimpleGraph.path_intersection_of_separator ⟨X, hX_sep⟩ py qx; simp_all
      simp_all [ Finset.ext_iff ];
    tauto

/-
If X separates A and B, and we have k disjoint paths from A to X and k disjoint paths from X to B, then we can combine them to form k disjoint paths from A to B.
-/
theorem SimpleGraph.disjoint_paths_join (G : SimpleGraph V) (A B : Finset V) (X : Finset V)
  (hX_sep : G.Separates A B X)
  (k : ℕ)
  (hX_card : X.card = k)
  (P_A : G.Joiner A X)
  (hP_A_card : P_A.1.card = k)
  (P_B : G.Joiner X B)
  (hP_B_card : P_B.1.card = k) :
  ∃ P : G.Joiner A B, P.1.card = k := by
    have h_unique_paths : ∀ x ∈ X, ∃! p ∈ P_A.1, p.v = x ∧ p.walk.support.toFinset ∩ X = {x} := by
      have := SimpleGraph.disjoint_paths_prop G A ( ↑X ) P_A; aesop;
    have h_unique_paths_start : ∀ x ∈ X, ∃! q ∈ P_B.1, q.u = x ∧ q.walk.support.toFinset ∩ X = {x} := by
      have := SimpleGraph.disjoint_paths_prop_start G X B P_B; aesop;
    generalize_proofs at *; (
    choose! p hp hp' using h_unique_paths
    generalize_proofs at *; (
    choose! q hq hq' using h_unique_paths_start
    generalize_proofs at *; (
    refine ⟨⟨Finset.image (fun (x : X) => ⟨p x x.2 |>.u, q x x.2 |>.v, ?_, ?_⟩) (Finset.univ : Finset X), ?_⟩, ?_⟩
    any_goals rw [ Finset.card_image_of_injOn ];
    · apply p x x.2 |>.walk.copy rfl (hp x x.2 |>.2.1) |>.append
      exact q x x.2 |>.walk.copy ( hq x x.2 |>.2.1 ) rfl
    · refine
      joined_path_is_path G A B X hX_sep (↑x) (p (↑x) x.property) (hp (↑x) x.property).right.left ?_
        (q (↑x) x.property) (hq (↑x) x.property).right.left ?_
      · simp [hp]
      · simp [hq]
    · intro p hp q hq hpq;
      rw [ Finset.mem_image ] at hp hq
      obtain ⟨x, hx, rfl⟩ := hp
      obtain ⟨y, hy, rfl⟩ := hq
      generalize_proofs at *;
      by_cases hxy : x = y;
      · grind;
      · convert SimpleGraph.joined_paths_disjoint G A B X hX_sep x y ( by simpa ) ( p x x.2 ) ( hp x x.2 |>.2.1 ) ( hp x x.2 |>.2.2 ) ( p y y.2 ) ( hp y y.2 |>.2.1 ) ( hp y y.2 |>.2.2 ) ( q x x.2 ) ( hq x x.2 |>.2.1 ) ( hq x x.2 |>.2.2 ) ( q y y.2 ) ( hq y y.2 |>.2.1 ) ( hq y y.2 |>.2.2 ) _ _ using 1;
        · simp [ Finset.ext_iff ];
        · simp [ Finset.ext_iff ];
        · have := P_A.2 ( p x x.2 ) ( hp x x.2 |>.1 ) ( p y y.2 ) ( hp y y.2 |>.1 ) ; simp_all [ Finset.disjoint_left ] ;
          grind;
        · have := P_B.2 ( q x x.2 ) ( hq x x.2 |>.1 ) ( q y y.2 ) ( hq y y.2 |>.1 ) ; simp_all [ Finset.disjoint_left ] ;
          exact this ( by intro h; have := hq x x.2; have := hq y y.2; aesop );
    · simp [ hX_card ];
    · intro x hx y hy hxy; simp_all [ Finset.ext_iff ] ;
      have := P_A.2 ( p x x.2 ) ( hp x x.2 |>.1 ) ( p y y.2 ) ( hp y y.2 |>.1 )
      simp_all [ Finset.disjoint_left ] ;
      contrapose! this;
      refine' ⟨ _, _ ⟩;
      · exact fun h => this ( Subtype.ext <| by have := hp x x.2; have := hp y y.2; aesop );
      · use (p x x.2).u;
        exact ⟨ by simp, by simp [ hxy.1 ] ⟩)))

/-
If a set Y separates A and B in the contracted graph, then its preimage separates A and B in the original graph.
-/
universe u

lemma SimpleGraph.contractEdge_separator_lift_separates {V : Type u} [Fintype V] (G : SimpleGraph V) (A B : Finset V) (x y : V)
  (Y : Finset (Quotient (SimpleGraph.contractEdgeSetoid x y)))
  (hY : (G.contractEdge' x y).Separates (SimpleGraph.contractEdge_liftSet x y A) (SimpleGraph.contractEdge_liftSet x y B) Y) :
  G.Separates A B ((SimpleGraph.contractEdge_preimage x y Y)) := by
    exact contractEdge_preimage_separates ⟨Y, hY⟩

/-
The size of the preimage of a set Y containing the contracted vertex is |Y| + 1.
-/
lemma SimpleGraph.contractEdge_separator_lift_card [Fintype V] (x y : V) (hxy : x ≠ y)
  (Y : Finset (Quotient (SimpleGraph.contractEdgeSetoid x y)))
  (h_ve : SimpleGraph.contractEdge_vertex x y ∈ Y) :
  (SimpleGraph.contractEdge_preimage x y Y).card = Y.card + 1 := by
    rw [ card_preimage_contractEdge ] ; aesop;
    assumption

/-
Base case for lifting a path: if the path is nil (start = end = contracted vertex), we can lift it to a nil path at x or y.
-/
lemma SimpleGraph.lift_path_to_contraction_nil [Fintype V] (G : SimpleGraph V) (A : Finset V) (x y : V)
  (u' : Quotient (SimpleGraph.contractEdgeSetoid x y))
  (p' : (G.contractEdge' x y).Walk u' (SimpleGraph.contractEdge_vertex x y))
  (hp'_path : p'.IsPath)
  (hp'_end : p'.support.toFinset ∩ {SimpleGraph.contractEdge_vertex x y} = {SimpleGraph.contractEdge_vertex x y})
  (hu' : u' ∈ SimpleGraph.contractEdge_liftSet x y A)
  (h_eq : u' = SimpleGraph.contractEdge_vertex x y) :
  ∃ (u v : V) (p : G.Walk u v),
    u ∈ A ∧
    (v = x ∨ v = y) ∧
    p.IsPath ∧
    p.support.toFinset ⊆ SimpleGraph.contractEdge_preimage x y p'.support.toFinset := by
      simp [contractEdge_liftSet] at hu'
      obtain ⟨ u, hu, rfl ⟩ := hu';
      -- By definition of `contractEdgeProj`, we know that `u = x` or `u = y`.
      have h_cases : u = x ∨ u = y := by
        exact (contractEdgeProj_eq_vertex_iff x y u).mp h_eq;
      unfold contractEdge_preimage; aesop;

/-
If a walk is a path and the start is not the end, it can be decomposed into a prefix path avoiding the end vertex, and a final edge.
-/
lemma SimpleGraph.Walk.exists_prefix_path_of_path_ne {G : SimpleGraph V}
  {u v : V} (p : G.Walk u v) (hp : p.IsPath) (h_ne : u ≠ v) :
  ∃ (w : V) (q : G.Walk u w),
    G.Adj w v ∧
    q.IsPath ∧
    v ∉ q.support ∧
    q.support.toFinset ⊆ p.support.toFinset := by
      simp +zetaDelta at *;
      induction' p with u v p ih;
      · contradiction;
      · rename_i h₁ h₂ h₃;
        by_cases h : p = ih;
        · aesop;
        · obtain ⟨ w, hw₁, q, hq₁, hq₂, hq₃ ⟩ := h₃ ( by
            cases h₂ <;> aesop ) h;
          refine' ⟨ w, hw₁, cons h₁ q, _, _, _ ⟩ <;> simp_all
          · exact fun h => hp.2 ( by simpa using hq₃ ( by simpa using h ) );
          · grind

/-
The preimages of disjoint sets in the contracted graph are disjoint in the original graph.
-/
lemma SimpleGraph.contractEdge_preimage_disjoint [Fintype V] (x y : V) (s t : Finset (Quotient (SimpleGraph.contractEdgeSetoid x y))) (h : Disjoint s t) :
  Disjoint (SimpleGraph.contractEdge_preimage x y s) (SimpleGraph.contractEdge_preimage x y t) := by
    rw [ Finset.disjoint_left ] at *;
    unfold contractEdge_preimage; aesop;

/-
If two vertices are adjacent to the endpoints of an edge, there is a path between them using only the endpoints of the edge and themselves.
-/
lemma SimpleGraph.exists_path_between_neighbors_of_edge (G : SimpleGraph V) (x y a b : V) (hxy : G.Adj x y) (ha : G.Adj a x ∨ G.Adj a y) (hb : G.Adj b x ∨ G.Adj b y) (hab : a ≠ b) (hax : a ≠ x) (hay : a ≠ y) (hbx : b ≠ x) (hby : b ≠ y) : ∃ p : G.Walk a b, p.IsPath ∧ p.support.toFinset ⊆ {a, b, x, y} := by
  rcases ha with ha | ha <;> rcases hb with hb | hb;
  · -- In this case, the path is simply a → x → b.
    use SimpleGraph.Walk.cons ha (SimpleGraph.Walk.cons hb.symm SimpleGraph.Walk.nil);
    aesop_cat;
  · use SimpleGraph.Walk.cons ha (SimpleGraph.Walk.cons hxy (SimpleGraph.Walk.cons hb.symm SimpleGraph.Walk.nil));
    aesop_cat;
  · use SimpleGraph.Walk.cons ha (SimpleGraph.Walk.cons hxy.symm (SimpleGraph.Walk.cons hb.symm SimpleGraph.Walk.nil));
    aesop_cat;
  · refine' ⟨ SimpleGraph.Walk.cons ha ( SimpleGraph.Walk.cons hb.symm SimpleGraph.Walk.nil ), _, _ ⟩ <;> simp_all [ SimpleGraph.Walk.isPath_def ];
    · grind;
    · simp [ Finset.insert_subset_iff ]

/-
Extending a path that avoids x and y by an edge to x (or y) results in a path.
-/
lemma SimpleGraph.path_extension_to_contraction_endpoint {G : SimpleGraph V} {u w : V} (x y : V) (v : V)
  (q : G.Walk u w) (hq_path : q.IsPath)
  (hx_avoid : x ∉ q.support) (hy_avoid : y ∉ q.support)
  (hv : v = x ∨ v = y)
  (h_adj : G.Adj w v) :
  (q.append (SimpleGraph.Walk.cons h_adj SimpleGraph.Walk.nil)).IsPath := by
    cases hv <;> simp_all [ SimpleGraph.Walk.isPath_def ];
    · rw [ SimpleGraph.Walk.support_append ];
      rw [ List.nodup_append ] ; aesop;
    · simp_all [ SimpleGraph.Walk.support_append ];
      rw [ List.nodup_append ] ; aesop

/-
If the projection of a set is contained in another set, and the contracted vertex is in that other set, then extending the first set by an endpoint of the contracted edge keeps it within the preimage.
-/
lemma SimpleGraph.support_subset_preimage_extension [Fintype V] (x y : V)
  (q_support : Finset V) (p'_support : Finset (Quotient (SimpleGraph.contractEdgeSetoid x y))) (v : V)
  (h_subset : q_support.image (SimpleGraph.contractEdgeProj x y) ⊆ p'_support)
  (h_ve : SimpleGraph.contractEdge_vertex x y ∈ p'_support)
  (hv : v = x ∨ v = y) :
  (q_support ∪ {v}) ⊆ SimpleGraph.contractEdge_preimage x y p'_support := by
    refine Finset.union_subset ( fun u hu => ?_ ) ( ?_ );
    · exact Finset.mem_filter.mpr ⟨ Finset.mem_univ _, h_subset ( Finset.mem_image_of_mem _ hu ) ⟩;
    · simp_all [ contractEdge_preimage ];
      convert h_ve using 1;
      exact Quot.sound ( by tauto )

/-
If a path ends at a vertex whose projection is adjacent to the contracted vertex, and the path avoids the contracted edge's endpoints, it can be extended to one of the endpoints.
-/
lemma SimpleGraph.lift_path_extension_step (G : SimpleGraph V) (x y : V)
  (u w : V) (q : G.Walk u w)
  (hq_path : q.IsPath)
  (hx_avoid : x ∉ q.support) (hy_avoid : y ∉ q.support)
  (hw_proj_adj : (G.contractEdge' x y).Adj (SimpleGraph.contractEdgeProj x y w) (SimpleGraph.contractEdge_vertex x y)) :
  ∃ (v : V) (p : G.Walk u v),
    (v = x ∨ v = y) ∧
    p.IsPath ∧
    p.support.toFinset ⊆ q.support.toFinset ∪ {v} ∧
    p.support.toFinset ∩ {x, y} = {v} := by
      have h_w_adj : G.Adj w x ∨ G.Adj w y := by
        have := SimpleGraph.contractEdge_adj_lift_vertex G x y w ?_ hw_proj_adj <;> aesop;
      cases' h_w_adj with h h;
      · refine' ⟨ x, q.append ( SimpleGraph.Walk.cons h SimpleGraph.Walk.nil ), Or.inl rfl, _, _, _ ⟩ <;> simp_all [ SimpleGraph.Walk.isPath_def ];
        · simp_all [ SimpleGraph.Walk.support_append ];
          rw [ List.nodup_append ] ; aesop;
        · simp [ SimpleGraph.Walk.support_append ];
        · ext ; aesop;
      · use y;
        use q.append (SimpleGraph.Walk.cons h SimpleGraph.Walk.nil);
        simp_all [ SimpleGraph.Walk.isPath_def ];
        simp_all [ SimpleGraph.Walk.support_append ];
        rw [ List.nodup_append ] ; aesop

/-
A path in the contracted graph ending at the contracted vertex can be lifted to a path in the original graph ending at one of the contracted edge's endpoints.
-/
lemma SimpleGraph.lift_path_to_contraction_end [Fintype V] (G : SimpleGraph V) (A : Finset V) (x y : V)
  (u' : Quotient (SimpleGraph.contractEdgeSetoid x y))
  (p' : (G.contractEdge' x y).Walk u' (SimpleGraph.contractEdge_vertex x y))
  (hp'_path : p'.IsPath)
  (hu' : u' ∈ SimpleGraph.contractEdge_liftSet x y A)
  (h_ne : u' ≠ SimpleGraph.contractEdge_vertex x y) :
  ∃ (u v : V) (p : G.Walk u v),
    u ∈ A ∧
    (v = x ∨ v = y) ∧
    p.IsPath ∧
    p.support.toFinset ⊆ SimpleGraph.contractEdge_preimage x y p'.support.toFinset ∧
    p.support.toFinset ∩ {x, y} = {v} := by
      norm_num +zetaDelta at *;
      obtain ⟨ w', q', hq'_path, hw'_adj ⟩ := SimpleGraph.Walk.exists_prefix_path_of_path_ne p' hp'_path h_ne;
      -- Lift $q'$ to a path $q$ in $G$ ending at $w$, avoiding $x,y$.
      obtain ⟨u, w, q, hu, hw, hq_path, hq_support⟩ : ∃ u w : V, ∃ q : G.Walk u w, u ∈ A ∧ SimpleGraph.contractEdgeProj x y u = u' ∧ SimpleGraph.contractEdgeProj x y w = w' ∧ q.IsPath ∧ q.support.toFinset.image (SimpleGraph.contractEdgeProj x y) ⊆ q'.support.toFinset ∧ x ∉ q.support ∧ y ∉ q.support := by
        have := SimpleGraph.lift_path_avoiding_contraction_AB G A .univ x y q' hw'_adj.2.1 hu' (by
        simp [contractEdge_liftSet]
        exact ⟨ Classical.choose ( Quotient.exists_rep w' ), Classical.choose_spec ( Quotient.exists_rep w' ) ⟩);
        aesop;
      -- Extend $q$ to a path $p$ ending at $v \in \{x,y\}$.
      obtain ⟨v, p, hv, hp_path, hp_support⟩ : ∃ v : V, ∃ p : G.Walk u v, (v = x ∨ v = y) ∧ p.IsPath ∧ p.support.toFinset ⊆ q.support.toFinset ∪ {v} ∧ p.support.toFinset ∩ {x, y} = {v} := by
        have := SimpleGraph.lift_path_extension_step G x y u w q hq_support.1 hq_support.2.2.1 hq_support.2.2.2 ?_ <;> aesop;
      -- Use `SimpleGraph.support_subset_preimage_extension` to conclude the support is in the preimage.
      have h_support_subset_preimage : p.support.toFinset ⊆ SimpleGraph.contractEdge_preimage x y p'.support.toFinset := by
        refine' Finset.Subset.trans hp_support.1 _;
        apply SimpleGraph.support_subset_preimage_extension;
        · apply Finset.Subset.trans hq_support.2.1
          have := hw'_adj.2.2
          convert this
        · aesop;
        · exact hv;
      grind

/-
A path in the contracted graph starting at the contracted vertex can be lifted to a path in the original graph starting at one of the contracted edge's endpoints.
-/
lemma SimpleGraph.lift_path_from_contraction_start [Fintype V] (G : SimpleGraph V) (B : Finset V) (x y : V)
  (v' : Quotient (SimpleGraph.contractEdgeSetoid x y))
  (p' : (G.contractEdge' x y).Walk (SimpleGraph.contractEdge_vertex x y) v')
  (hp'_path : p'.IsPath)
  (hv' : v' ∈ SimpleGraph.contractEdge_liftSet x y B)
  (h_ne : v' ≠ SimpleGraph.contractEdge_vertex x y) :
  ∃ (u v : V) (p : G.Walk u v),
    (u = x ∨ u = y) ∧
    v ∈ B ∧
    p.IsPath ∧
    p.support.toFinset ⊆ SimpleGraph.contractEdge_preimage x y p'.support.toFinset ∧
    p.support.toFinset ∩ {x, y} = {u} := by
      have h_lift_reversed : ∃ u v : V, ∃ p : G.Walk u v, u ∈ B ∧
        (v = x ∨ v = y) ∧
        p.IsPath ∧
        p.support.toFinset ⊆ (contractEdge_preimage x y (p'.reverse.support.toFinset)) ∧
        p.support.toFinset ∩ {x, y} = {v} := by
          apply_rules [ SimpleGraph.lift_path_to_contraction_end ];
          · exact (Walk.isPath_reverse_iff p').mpr hp'_path;
      obtain ⟨ u, v, p, hu, hv, hp, hp', hp'' ⟩ := h_lift_reversed; use v, u, p.reverse; aesop;

/-
Two paths ending and starting at the endpoints of an edge can be joined into a single path if they are otherwise disjoint and avoid the edge's endpoints internally.
-/
lemma SimpleGraph.join_paths_through_edge (G : SimpleGraph V) (x y : V) (hxy : G.Adj x y)
  {u_start u_end v_start v_end : V}
  (p1 : G.Walk u_start u_end) (p2 : G.Walk v_start v_end)
  (hp1_path : p1.IsPath) (hp2_path : p2.IsPath)
  (hu_end : u_end = x ∨ u_end = y)
  (hv_start : v_start = x ∨ v_start = y)
  (hp1_end : p1.support.toFinset ∩ {x, y} = {u_end})
  (hp2_start : p2.support.toFinset ∩ {x, y} = {v_start})
  (h_disjoint : Disjoint (p1.support.toFinset \ {x, y}) (p2.support.toFinset \ {x, y})) :
  ∃ (q : G.Walk u_start v_end), q.IsPath ∧ q.support.toFinset ⊆ p1.support.toFinset ∪ p2.support.toFinset := by
    by_cases h_cases : u_end = v_start;
    · refine' ⟨ p1.append ( h_cases ▸ p2 ), _, _ ⟩ <;> simp_all
      · -- Since p1 and p2 are disjoint except at v_start, and they are both paths, their concatenation is also a path.
        have h_concat_path : (p1.append (h_cases ▸ p2)).IsPath := by
          have h_disjoint : Disjoint (p1.support.toFinset \ {v_start}) (p2.support.toFinset \ {v_start}) := by
            simp_all [ Finset.disjoint_left ];
            intro a ha ha' ha''; specialize h_disjoint ha; simp_all [ Finset.eq_singleton_iff_unique_mem ] ;
            grind +ring
          apply SimpleGraph.Walk.IsPath_append_of_support_inter_subset_one;
          · assumption;
          · aesop;
          · intro v hv; simp_all [ Finset.disjoint_left ] ;
            grind;
        exact h_concat_path;
      · intro v hv; aesop;
    · -- Since $u_{end} \neq v_{start}$, one is $x$ and the other is $y$. Since $x \sim y$, there is an edge between them.
      obtain ⟨h_edge, h_cases⟩ : G.Adj u_end v_start ∧ (u_end = x ∧ v_start = y ∨ u_end = y ∧ v_start = x) := by
        cases hu_end <;> cases hv_start <;> simp_all [ SimpleGraph.adj_comm ];
      -- We can form the walk $p_1 ++ (u_{end}, v_{start}) ++ p_2$.
      use p1.append (SimpleGraph.Walk.cons h_edge p2);
      simp_all [ Finset.subset_iff, SimpleGraph.Walk.isPath_def ];
      simp_all [ Finset.disjoint_left ];
      simp_all [ Finset.ext_iff, SimpleGraph.Walk.support_append ];
      grind

/-
A path can be split at any vertex in its support into two paths that intersect only at that vertex.
-/
lemma SimpleGraph.Walk.split_at_vertex {G : SimpleGraph V} {u v : V} (p : G.Walk u v) (hp : p.IsPath) (z : V) (hz : z ∈ p.support) :
  ∃ (p1 : G.Walk u z) (p2 : G.Walk z v),
    p1.IsPath ∧ p2.IsPath ∧
    p1.support.toFinset ∩ p2.support.toFinset = {z} ∧
    p1.support.toFinset ∪ p2.support.toFinset = p.support.toFinset := by
      simp +zetaDelta at *;
      -- Let `p1` be the prefix of `p` ending at `z`, and `p2` be the suffix of `p` starting at `z`.
      obtain ⟨p1, p2, hp1, hp2, hp_split⟩ : ∃ p1 : G.Walk u z, ∃ p2 : G.Walk z v, p = p1.append p2 ∧ p1.IsPath ∧ p2.IsPath := by
        exact ⟨ p.takeUntil z hz, p.dropUntil z hz, by rw [ SimpleGraph.Walk.take_spec ], by exact hp.takeUntil _, by exact hp.dropUntil _ ⟩;
      refine' ⟨ p1, hp2, p2, hp_split, _, _ ⟩ <;> simp_all [ Finset.ext_iff ];
      intro a; constructor <;> intro ha ; simp_all [ SimpleGraph.Walk.isPath_def ] ;
      · induction' p1 with u' p1 ih generalizing a ; induction' p2 with v' p2 ih' ; aesop;
        · aesop;
        · simp_all [ SimpleGraph.Walk.support ];
          grind +ring;
      · aesop

/-
If a walk is a path, its support intersects the singleton set of its endpoint exactly at that point.
-/
lemma SimpleGraph.Walk.IsPath.support_inter_singleton_eq_of_end {G : SimpleGraph V} {u v : V} (p : G.Walk u v) (hp : p.IsPath) :
  p.support.toFinset ∩ {v} = {v} := by
    cases p <;> aesop

/-
If a walk is a path, its support intersects the singleton set of its start point exactly at that point.
-/
lemma SimpleGraph.Walk.IsPath.support_inter_singleton_eq_of_start {G : SimpleGraph V} {u v : V} (p : G.Walk u v) :
  p.support.toFinset ∩ {u} = {u} := by
    -- Since `p` is a path, it contains no repeated vertices. `u` is in the support of `p`. Thus `u` appears exactly once in the support. So the intersection with `{u}` is `{u}`.
    ext; simp

/-
If two sets in the contracted graph are disjoint away from the contracted vertex, their preimages in the original graph are disjoint away from the endpoints of the contracted edge.
-/
lemma SimpleGraph.contractEdge_preimage_disjoint_away_from_endpoints [Fintype V] (x y : V)
  (s t : Finset (Quotient (SimpleGraph.contractEdgeSetoid x y)))
  (h_disj : Disjoint (s \ {SimpleGraph.contractEdge_vertex x y}) (t \ {SimpleGraph.contractEdge_vertex x y})) :
  Disjoint (SimpleGraph.contractEdge_preimage x y s \ {x, y}) (SimpleGraph.contractEdge_preimage x y t \ {x, y}) := by
    unfold contractEdge_preimage;
    simp_all [ Finset.disjoint_left ];
    intro a ha hx hy; specialize h_disj ha; simp_all [ SimpleGraph.contractEdgeProj, SimpleGraph.contractEdge_vertex ] ;
    apply h_disj
    simp [Quotient.eq, contractEdgeSetoid, hx, hy]

/-
If two paths in the contracted graph intersect only at the contracted vertex, their lifted paths in the original graph are disjoint away from the endpoints of the contracted edge.
-/
lemma SimpleGraph.lifted_paths_disjoint [Fintype V] (G : SimpleGraph V) (x y : V)
  (p1' : (G.contractEdge' x y).Walk (SimpleGraph.contractEdgeProj x y x) (SimpleGraph.contractEdge_vertex x y)) -- start doesn't matter much
  (p2' : (G.contractEdge' x y).Walk (SimpleGraph.contractEdge_vertex x y) (SimpleGraph.contractEdgeProj x y x)) -- end doesn't matter much
  (h_inter : p1'.support.toFinset ∩ p2'.support.toFinset = {SimpleGraph.contractEdge_vertex x y})
  (p1 : G.Walk x x) -- endpoints don't matter for support
  (p2 : G.Walk x x) -- endpoints don't matter for support
  (h_sub1 : p1.support.toFinset ⊆ SimpleGraph.contractEdge_preimage x y p1'.support.toFinset)
  (h_sub2 : p2.support.toFinset ⊆ SimpleGraph.contractEdge_preimage x y p2'.support.toFinset) :
  Disjoint (p1.support.toFinset \ {x, y}) (p2.support.toFinset \ {x, y}) := by
    -- Apply the lemma that states the preimages of disjoint sets are disjoint away from the endpoints of the contracted edge.
    have h_disjoint : Disjoint (SimpleGraph.contractEdge_preimage x y p1'.support.toFinset \ {x, y}) (SimpleGraph.contractEdge_preimage x y p2'.support.toFinset \ {x, y}) := by
      apply SimpleGraph.contractEdge_preimage_disjoint_away_from_endpoints x y
      exact Finset.disjoint_left.mpr fun z hz1 hz2 => by rw [ Finset.ext_iff ] at h_inter; specialize h_inter z; aesop;
    exact h_disjoint.mono ( fun z => by aesop ) ( fun z => by aesop )

/-
If two paths in the contracted graph meet only at the contracted vertex, they can be lifted to paths in the original graph that are disjoint away from the contracted edge's endpoints.
-/
lemma SimpleGraph.lift_split_paths [Fintype V] (G : SimpleGraph V) (A B : Finset V) (x y : V)
  (u' v' : Quotient (SimpleGraph.contractEdgeSetoid x y))
  (p1' : (G.contractEdge' x y).Walk u' (SimpleGraph.contractEdge_vertex x y))
  (p2' : (G.contractEdge' x y).Walk (SimpleGraph.contractEdge_vertex x y) v')
  (hp1'_path : p1'.IsPath)
  (hp2'_path : p2'.IsPath)
  (h_inter : p1'.support.toFinset ∩ p2'.support.toFinset = {SimpleGraph.contractEdge_vertex x y})
  (h_u_ne : u' ≠ SimpleGraph.contractEdge_vertex x y)
  (h_v_ne : v' ≠ SimpleGraph.contractEdge_vertex x y)
  (hu' : u' ∈ SimpleGraph.contractEdge_liftSet x y A)
  (hv' : v' ∈ SimpleGraph.contractEdge_liftSet x y B) :
  ∃ (u_start u_end : V) (p1 : G.Walk u_start u_end) (v_start v_end : V) (p2 : G.Walk v_start v_end),
    u_start ∈ A ∧ v_end ∈ B ∧
    (u_end = x ∨ u_end = y) ∧ (v_start = x ∨ v_start = y) ∧
    p1.IsPath ∧ p2.IsPath ∧
    p1.support.toFinset ⊆ SimpleGraph.contractEdge_preimage x y p1'.support.toFinset ∧
    p2.support.toFinset ⊆ SimpleGraph.contractEdge_preimage x y p2'.support.toFinset ∧
    p1.support.toFinset ∩ {x, y} = {u_end} ∧
    p2.support.toFinset ∩ {x, y} = {v_start} ∧
    Disjoint (p1.support.toFinset \ {x, y}) (p2.support.toFinset \ {x, y}) := by
      -- Apply `SimpleGraph.lift_path_to_contraction_end` on `p1'` to get `p1` from `u_start` to `u_end`.
      obtain ⟨u_start, u_end, p1, hp1⟩ : ∃ (u_start : V) (u_end : V) (p1 : G.Walk u_start u_end),
        u_start ∈ A ∧
        (u_end = x ∨ u_end = y) ∧
        p1.IsPath ∧
        p1.support.toFinset ⊆ SimpleGraph.contractEdge_preimage x y p1'.support.toFinset ∧
        p1.support.toFinset ∩ {x, y} = {u_end} := by
          apply SimpleGraph.lift_path_to_contraction_end G A x y u' p1' hp1'_path (by
          simp_all [ Finset.ext_iff ]) h_u_ne;
      -- Apply `SimpleGraph.lift_path_from_contraction_start` on `p2'` to get `p2` from `v_start` to `v_end`.
      obtain ⟨v_start, v_end, p2, hp2⟩ : ∃ (v_start : V) (v_end : V) (p2 : G.Walk v_start v_end),
        (v_start = x ∨ v_start = y) ∧
        v_end ∈ B ∧
        p2.IsPath ∧
        p2.support.toFinset ⊆ SimpleGraph.contractEdge_preimage x y p2'.support.toFinset ∧
        p2.support.toFinset ∩ {x, y} = {v_start} := by
          have := SimpleGraph.lift_path_from_contraction_start G B x y v' p2' hp2'_path ( by
            simp_all [ Finset.eq_singleton_iff_unique_mem ] ) h_v_ne;
          tauto;
      refine' ⟨ u_start, u_end, p1, v_start, v_end, p2, hp1.1, hp2.2.1, hp1.2.1, hp2.1, hp1.2.2.1, hp2.2.2.1, hp1.2.2.2.1, hp2.2.2.2.1, hp1.2.2.2.2, hp2.2.2.2.2, _ ⟩;
      have h_lifted_paths_disjoint : Disjoint (SimpleGraph.contractEdge_preimage x y p1'.support.toFinset \ {x, y}) (SimpleGraph.contractEdge_preimage x y p2'.support.toFinset \ {x, y}) := by
        apply SimpleGraph.contractEdge_preimage_disjoint_away_from_endpoints x y p1'.support.toFinset p2'.support.toFinset;
        simp_all [ Finset.disjoint_left, Finset.ext_iff ];
        exact fun a ha₁ ha₂ ha₃ => ha₂ <| h_inter a |>.1 ⟨ ha₁, ha₃ ⟩;
      exact h_lifted_paths_disjoint.mono ( Finset.sdiff_subset_sdiff hp1.2.2.2.1 ( Finset.Subset.refl _ ) ) ( Finset.sdiff_subset_sdiff hp2.2.2.2.1 ( Finset.Subset.refl _ ) )

/-
A path in the contracted graph passing through the contracted vertex can be lifted to a path in the original graph.
-/
lemma SimpleGraph.lift_path_through_contraction_internal [Fintype V] (G : SimpleGraph V) (A B : Finset V) (x y : V) (hxy : G.Adj x y)
  (u' v' : Quotient (SimpleGraph.contractEdgeSetoid x y))
  (p' : (G.contractEdge' x y).Walk u' v')
  (hp'_path : p'.IsPath)
  (h_ve_mem : SimpleGraph.contractEdge_vertex x y ∈ p'.support)
  (h_u_ne : u' ≠ SimpleGraph.contractEdge_vertex x y)
  (h_v_ne : v' ≠ SimpleGraph.contractEdge_vertex x y)
  (hu' : u' ∈ SimpleGraph.contractEdge_liftSet x y A)
  (hv' : v' ∈ SimpleGraph.contractEdge_liftSet x y B) :
  ∃ (u v : V) (p : G.Walk u v),
    u ∈ A ∧ v ∈ B ∧
    p.IsPath ∧
    p.support.toFinset ⊆ SimpleGraph.contractEdge_preimage x y p'.support.toFinset := by
      have h_split : ∃ (p1' : (G.contractEdge' x y).Walk u' (SimpleGraph.contractEdge_vertex x y)) (p2' : (G.contractEdge' x y).Walk (SimpleGraph.contractEdge_vertex x y) v'),
        p1'.IsPath ∧
        p2'.IsPath ∧
        p1'.support.toFinset ∩ p2'.support.toFinset = {SimpleGraph.contractEdge_vertex x y} ∧
        p1'.support.toFinset ∪ p2'.support.toFinset = p'.support.toFinset := by
          have := SimpleGraph.Walk.split_at_vertex p' hp'_path _ h_ve_mem;
          obtain ⟨p1, p2, hp1, hp2, h1, h2⟩ := this
          refine ⟨p1, p2, hp1, hp2, ?_, ?_⟩
          convert h1 ; convert h2
      obtain ⟨p1', p2', hp1'_path, hp2'_path, h_inter, h_union⟩ := h_split;
      obtain ⟨u_start, u_end, p1, v_start, v_end, p2, hp1, hp2, h_disjoint⟩ : ∃ (u_start u_end : V) (p1 : G.Walk u_start u_end) (v_start v_end : V) (p2 : G.Walk v_start v_end),
        u_start ∈ A ∧ v_end ∈ B ∧
        (u_end = x ∨ u_end = y) ∧ (v_start = x ∨ v_start = y) ∧
        p1.IsPath ∧ p2.IsPath ∧
        p1.support.toFinset ⊆ SimpleGraph.contractEdge_preimage x y p1'.support.toFinset ∧
        p2.support.toFinset ⊆ SimpleGraph.contractEdge_preimage x y p2'.support.toFinset ∧
        p1.support.toFinset ∩ {x, y} = {u_end} ∧
        p2.support.toFinset ∩ {x, y} = {v_start} ∧
        Disjoint (p1.support.toFinset \ {x, y}) (p2.support.toFinset \ {x, y}) := by
          exact
            lift_split_paths G A B x y u' v' p1' p2' hp1'_path hp2'_path h_inter h_u_ne h_v_ne
              hu' hv';
      obtain ⟨q, hq⟩ : ∃ q : G.Walk u_start v_end, q.IsPath ∧ q.support.toFinset ⊆ p1.support.toFinset ∪ p2.support.toFinset := by
        apply SimpleGraph.join_paths_through_edge G x y hxy p1 p2 h_disjoint.2.2.1 h_disjoint.2.2.2.1 h_disjoint.1 h_disjoint.2.1 h_disjoint.2.2.2.2.2.2.1 h_disjoint.2.2.2.2.2.2.2.1 h_disjoint.2.2.2.2.2.2.2.2;
      have h_union_subset : contractEdge_preimage x y p1'.support.toFinset ∪ contractEdge_preimage x y p2'.support.toFinset ⊆ contractEdge_preimage x y (p1'.support.toFinset ∪ p2'.support.toFinset) := by
        simp [ Finset.subset_iff, SimpleGraph.contractEdge_preimage ];
      grind

/-
A path in the contracted graph that avoids the contracted vertex can be lifted to a path in the original graph that avoids the endpoints of the contracted edge.
-/
lemma SimpleGraph.exists_lifted_ABPath_avoiding (G : SimpleGraph V) (A B : Finset V) (x y : V)
  (p' : (G.contractEdge' x y).ABPath (SimpleGraph.contractEdge_liftSet x y A) (SimpleGraph.contractEdge_liftSet x y B))
  (hp'_avoid : SimpleGraph.contractEdge_vertex x y ∉ p'.walk.support) :
  ∃ p : G.ABPath A B,
    SimpleGraph.contractEdgeProj x y p.u = p'.u ∧
    SimpleGraph.contractEdgeProj x y p.v = p'.v ∧
    p.walk.support.toFinset.image (SimpleGraph.contractEdgeProj x y) ⊆ p'.walk.support.toFinset ∧
    x ∉ p.walk.support ∧ y ∉ p.walk.support := by
      -- Apply the `lift_path_avoiding_contraction_AB` lemma to obtain the path `q` in `G`.
      obtain ⟨u, v, q, hu, hv, hq_isPath, hq_support⟩ : ∃ u v : V, ∃ q : G.Walk u v, (u ∈ A ∧ v ∈ B ∧ SimpleGraph.contractEdgeProj x y u = p'.u ∧ SimpleGraph.contractEdgeProj x y v = p'.v ∧ q.IsPath ∧ (q.support.toFinset.image (SimpleGraph.contractEdgeProj x y)) ⊆ p'.walk.support.toFinset ∧ x ∉ q.support ∧ y ∉ q.support) := by
        rcases p' with ⟨ u', v', p', hp'_path ⟩;
        obtain ⟨ u, v, q, hq ⟩ := SimpleGraph.lift_path_avoiding_contraction_AB G A B x y p' hp'_avoid u'.2 v'.2;
        exact ⟨ u, v, q, hq ⟩;
      refine' ⟨ ⟨ ⟨ u, hu ⟩, ⟨ v, hv ⟩, q, hq_support.2.1 ⟩, _, _, _, _ ⟩ <;> aesop

/-
The contracted vertex is in the lifted set of A if and only if x or y is in A.
-/
lemma SimpleGraph.mem_liftSet_contraction_vertex_iff (A : Finset V) (x y : V) :
  SimpleGraph.contractEdge_vertex x y ∈ SimpleGraph.contractEdge_liftSet x y A ↔ x ∈ A ∨ y ∈ A := by
    unfold SimpleGraph.contractEdge_liftSet SimpleGraph.contractEdge_vertex SimpleGraph.contractEdgeProj;
    constructor <;> intro h;
    · simp at h
      cases' h with z hz;
      simp [Quotient.eq, contractEdgeSetoid] at hz;
      aesop;
    · simp
      cases' h with hx hy;
      · exact ⟨ x, hx, rfl ⟩;
      · exact ⟨ y, hy, by simp [ Quotient.eq, SimpleGraph.contractEdgeSetoid ] ⟩

/-
If a path starts at one of the endpoints of the contracted edge, and the contracted vertex is in the lifted set of A, we can adjust the path to start in A.
-/
lemma SimpleGraph.adjust_path_start_to_A (G : SimpleGraph V) (A : Finset V) (x y : V) (hxy : G.Adj x y)
  (u v : V) (p : G.Walk u v) (hp_path : p.IsPath)
  (hu : u = x ∨ u = y)
  (hp_support : p.support.toFinset ∩ {x, y} = {u})
  (h_liftA : SimpleGraph.contractEdge_vertex x y ∈ SimpleGraph.contractEdge_liftSet x y A) :
  ∃ (u' : V) (p' : G.Walk u' v),
    u' ∈ A ∧
    p'.IsPath ∧
    p'.support.toFinset.image (SimpleGraph.contractEdgeProj x y) ⊆ p.support.toFinset.image (SimpleGraph.contractEdgeProj x y) := by
      -- Since the contraction vertex is in the liftSet of A, either x or y must be in A. Let's consider both cases.
      by_cases hx : x ∈ A;
      · rcases hu with ( rfl | rfl );
        · exact ⟨ u, p, hx, hp_path, Finset.Subset.refl _ ⟩;
        · refine' ⟨ x, SimpleGraph.Walk.cons hxy p, hx, _, _ ⟩ <;> simp_all [ SimpleGraph.Walk.cons_isPath_iff ];
          · rw [ Finset.ext_iff ] at hp_support ; specialize hp_support x ; aesop;
          · simp_all [ Finset.Subset.antisymm_iff, Finset.subset_iff ];
            use u;
            exact ⟨ p.start_mem_support, by exact Quotient.sound ( by tauto ) ⟩;
      · by_cases hy : y ∈ A;
        · cases hu <;> simp_all [ Finset.subset_iff ];
          · refine' ⟨ y, hy, _, _, _ ⟩;
            exact SimpleGraph.Walk.cons hxy.symm ( p.copy ( by simp [ * ] ) rfl );
            · replace hp_support := Finset.ext_iff.mp hp_support y; aesop;
            · simp [ SimpleGraph.Walk.support_cons ];
              simp [ Finset.eq_singleton_iff_unique_mem, contractEdgeProj ] at hp_support ⊢;
              exact ⟨ ⟨ x, hp_support.1, by simp_all [Quotient.eq, SimpleGraph.contractEdgeSetoid ] ⟩,
              fun a ha => ⟨ a, ha, by tauto ⟩ ⟩;
          · grind;
        · simp_all [ contractEdge_liftSet ];
          obtain ⟨ u', hu', hu'' ⟩ := h_liftA;
          have := SimpleGraph.contractEdgeProj_eq_vertex_iff x y u';
            cases this.mp hu'' <;> simp_all [ Finset.ext_iff ]

/-
If a path ends at one of the endpoints of the contracted edge, and the contracted vertex is in the lifted set of B, we can adjust the path to end in B.
-/
lemma SimpleGraph.adjust_path_end_to_B (G : SimpleGraph V) (B : Finset V) (x y : V) (hxy : G.Adj x y)
  (u v : V) (p : G.Walk u v) (hp_path : p.IsPath)
  (hv : v = x ∨ v = y)
  (hp_support : p.support.toFinset ∩ {x, y} = {v})
  (h_liftB : SimpleGraph.contractEdge_vertex x y ∈ SimpleGraph.contractEdge_liftSet x y B) :
  ∃ (v' : V) (p' : G.Walk u v'),
    v' ∈ B ∧
    p'.IsPath ∧
    p'.support.toFinset.image (SimpleGraph.contractEdgeProj x y) ⊆ p.support.toFinset.image (SimpleGraph.contractEdgeProj x y) := by
      rcases hv with ( rfl | rfl );
      · by_cases hy : y ∈ B;
        · refine' ⟨ y, _, hy, _, _ ⟩;
          exact p.append ( SimpleGraph.Walk.cons hxy SimpleGraph.Walk.nil );
          · simp_all [ Finset.ext_iff, SimpleGraph.Walk.isPath_def ];
            rw [ SimpleGraph.Walk.support_append ];
            simp_all [ List.nodup_append ];
            intro a ha ha'; specialize hp_support a ha ha'; aesop;
          · simp [ Finset.subset_iff, SimpleGraph.Walk.support_append ];
            use v;
            simp_all [ Finset.eq_singleton_iff_unique_mem ];
            exact Quotient.sound ( by tauto );
        · -- Since $y \notin B$, we have $v \in B$.
          have hvB : v ∈ B := by
            exact Or.resolve_right ( SimpleGraph.mem_liftSet_contraction_vertex_iff B v y |>.1 h_liftB ) hy;
          exact ⟨ v, p, hvB, hp_path, Finset.Subset.refl _ ⟩;
      · by_cases hv : v ∈ B;
        · exact ⟨ v, p, hv, hp_path, Finset.Subset.refl _ ⟩;
        · -- Since $v \notin B$, we have $x \in B$.
          have hx : x ∈ B := by
            contrapose! h_liftB; simp_all [ contractEdge_liftSet ] ;
            intro w hw; rw [ SimpleGraph.contractEdgeProj, SimpleGraph.contractEdge_vertex ] ; simp_all [ Quotient.eq, SimpleGraph.contractEdgeSetoid ] ;
            grind;
          refine' ⟨ x, p.append ( SimpleGraph.Walk.cons hxy.symm SimpleGraph.Walk.nil ), hx, _, _ ⟩;
          · refine' SimpleGraph.Walk.IsPath_append_of_support_inter_subset_one _ _ hp_path _ _;
            · aesop;
            · rw [ Finset.eq_singleton_iff_unique_mem ] at hp_support ; aesop;
          · simp_all [ Finset.subset_iff ];
            rintro a ( ha | rfl | rfl ) <;> simp_all [ SimpleGraph.contractEdgeProj ];
            · exact ⟨ a, ha, by rfl ⟩;
            · exact ⟨ a, by cases p <;> aesop ⟩;
            · exact ⟨ v, by simp, by simp [Quotient.eq, SimpleGraph.contractEdgeSetoid]⟩

/-
Helper lemma: A path starting at the contracted vertex can be lifted to an A-B path if the contracted vertex is in the lifted set of A.
-/
lemma SimpleGraph.lift_path_start_eq_vertex [Fintype V] (G : SimpleGraph V) (A B : Finset V) (x y : V) (hxy : G.Adj x y)
  (v' : Quotient (SimpleGraph.contractEdgeSetoid x y))
  (p' : (G.contractEdge' x y).Walk (SimpleGraph.contractEdge_vertex x y) v')
  (hp'_path : p'.IsPath)
  (hv' : v' ∈ SimpleGraph.contractEdge_liftSet x y B)
  (h_end_ne : v' ≠ SimpleGraph.contractEdge_vertex x y)
  (h_liftA : SimpleGraph.contractEdge_vertex x y ∈ SimpleGraph.contractEdge_liftSet x y A) :
  ∃ p : G.ABPath A B,
    p.walk.support.toFinset.image (SimpleGraph.contractEdgeProj x y) ⊆ p'.support.toFinset := by
      -- By Lemma 2, there exists a path `q` in `G` starting at `u` (where `u = x` or `u = y`) and ending at `v` (where `v \in B`).
      obtain ⟨u, v, q, hq_path, hq_support⟩ : ∃ u v : V, ∃ q : G.Walk u v,
        (u = x ∨ u = y) ∧
        v ∈ B ∧
        q.IsPath ∧
        q.support.toFinset ⊆ SimpleGraph.contractEdge_preimage x y p'.support.toFinset ∧
        q.support.toFinset ∩ {x, y} = {u} := by
          exact ⟨ _, _, _, ( SimpleGraph.lift_path_from_contraction_start G B x y v' p' hp'_path hv' h_end_ne |> Classical.choose_spec |> Classical.choose_spec |> Classical.choose_spec ) |> And.left, ( SimpleGraph.lift_path_from_contraction_start G B x y v' p' hp'_path hv' h_end_ne |> Classical.choose_spec |> Classical.choose_spec |> Classical.choose_spec ) |> And.right |> And.left, ( SimpleGraph.lift_path_from_contraction_start G B x y v' p' hp'_path hv' h_end_ne |> Classical.choose_spec |> Classical.choose_spec |> Classical.choose_spec ) |> And.right |> And.right |> And.left, ( SimpleGraph.lift_path_from_contraction_start G B x y v' p' hp'_path hv' h_end_ne |> Classical.choose_spec |> Classical.choose_spec |> Classical.choose_spec ) |> And.right |> And.right |> And.right |> And.left, ( SimpleGraph.lift_path_from_contraction_start G B x y v' p' hp'_path hv' h_end_ne |> Classical.choose_spec |> Classical.choose_spec |> Classical.choose_spec ) |> And.right |> And.right |> And.right |> And.right ⟩;
      obtain ⟨ u', q', hu', hq', hq'_support ⟩ := SimpleGraph.adjust_path_start_to_A G A x y hxy u v q hq_support.2.1 hq_path hq_support.2.2.2 h_liftA;
      refine' ⟨ ⟨ ⟨ u', hu' ⟩, ⟨ v, hq_support.1 ⟩, q', hq' ⟩, _ ⟩;
      refine' Finset.Subset.trans hq'_support _;
      simp_all [ Finset.subset_iff ];
      intro a ha; specialize hq_support; replace hq_support := hq_support.2.2.1 ha; unfold contractEdge_preimage at hq_support; aesop;

/-
Helper lemma: A path ending at the contracted vertex can be lifted to an A-B path if the contracted vertex is in the lifted set of B.
-/
lemma SimpleGraph.lift_path_end_eq_vertex [Fintype V] (G : SimpleGraph V) (A B : Finset V) (x y : V) (hxy : G.Adj x y)
  (u' : Quotient (SimpleGraph.contractEdgeSetoid x y))
  (p' : (G.contractEdge' x y).Walk u' (SimpleGraph.contractEdge_vertex x y))
  (hp'_path : p'.IsPath)
  (hu' : u' ∈ SimpleGraph.contractEdge_liftSet x y A)
  (h_start_ne : u' ≠ SimpleGraph.contractEdge_vertex x y)
  (h_liftB : SimpleGraph.contractEdge_vertex x y ∈ SimpleGraph.contractEdge_liftSet x y B) :
  ∃ p : G.ABPath A B,
    p.walk.support.toFinset.image (SimpleGraph.contractEdgeProj x y) ⊆ p'.support.toFinset := by
      have := SimpleGraph.lift_path_to_contraction_end G A x y u' p' hp'_path hu' h_start_ne;
      obtain ⟨ u, v, p, hu, hv, hp, hp', hp'' ⟩ := this;
      -- Use `adjust_path_end_to_B` with `p` to get a path `q` in `G` starting at `u` and ending at `v' \in B`.
      obtain ⟨ v', q, hv', hq, hq' ⟩ : ∃ v' : V, ∃ q : G.Walk u v', v' ∈ B ∧ q.IsPath ∧ q.support.toFinset.image (contractEdgeProj x y) ⊆ p.support.toFinset.image (contractEdgeProj x y) := by
        apply_rules [ SimpleGraph.adjust_path_end_to_B ];
      -- Since the image of p's support under the contraction map is a subset of p'.support.toFinset, and the image of q's support is a subset of the image of p's support, their composition gives the desired subset.
      have h_final : Finset.image (contractEdgeProj x y) q.support.toFinset ⊆ p'.support.toFinset := by
        refine' Finset.Subset.trans hq' _;
        rw [ Finset.image_subset_iff ];
        intro z hz; specialize hp' hz; unfold contractEdge_preimage at hp'; aesop;
      exact ⟨ ⟨ ⟨ u, hu ⟩, ⟨ v', hv' ⟩, q, hq ⟩, h_final ⟩

/-
Helper lemma: A nil path at the contracted vertex can be lifted to an A-B path if the contracted vertex is in the lifted sets of A and B.
-/
lemma SimpleGraph.lift_path_nil_eq_vertex (G : SimpleGraph V) (A B : Finset V) (x y : V) (hxy : G.Adj x y)
  (p' : (G.contractEdge' x y).Walk (SimpleGraph.contractEdge_vertex x y) (SimpleGraph.contractEdge_vertex x y))
  (hp'_path : p'.IsPath)
  (h_liftA : SimpleGraph.contractEdge_vertex x y ∈ SimpleGraph.contractEdge_liftSet x y A)
  (h_liftB : SimpleGraph.contractEdge_vertex x y ∈ SimpleGraph.contractEdge_liftSet x y B) :
  ∃ p : G.ABPath A B,
    p.walk.support.toFinset.image (SimpleGraph.contractEdgeProj x y) ⊆ p'.support.toFinset := by
      -- Since x_1 and x_2 are in the same equivalence class under the quotient, they must be either x or y.
      simp [contractEdge_liftSet] at h_liftA h_liftB
      obtain ⟨x_1, hx_1_A, hx_1⟩ := h_liftA
      obtain ⟨x_2, hx_2_B, hx_2⟩ := h_liftB
      have hx_1_eq : x_1 = x ∨ x_1 = y := by
        contrapose! hx_1; simp_all [ Quotient.eq, SimpleGraph.contractEdge_vertex, SimpleGraph.contractEdgeProj ] ;
        unfold contractEdgeSetoid; aesop;
      have hx_2_eq : x_2 = x ∨ x_2 = y := by
        rw [ SimpleGraph.contractEdgeProj, SimpleGraph.contractEdge_vertex ] at hx_2;
        rw [ Quotient.eq ] at hx_2;
        cases hx_2 <;> aesop;
      cases hx_1_eq <;> cases hx_2_eq <;> simp_all [ contractEdge_vertex ];
      · refine' ⟨ _, _ ⟩;
        constructor;
        rotate_left;
        exact ⟨ x, hx_1_A ⟩;
        exact ⟨ x, hx_2_B ⟩;
        exact SimpleGraph.Walk.nil;
        all_goals simp [*];
      · refine' ⟨ ⟨ _, _, _, _ ⟩, _ ⟩ <;> norm_num;
        exact ⟨ x, hx_1_A ⟩;
        exact ⟨ y, hx_2_B ⟩;
        exact SimpleGraph.Walk.cons hxy SimpleGraph.Walk.nil;
        all_goals simp [ SimpleGraph.Walk.cons_isPath_iff, hxy.ne ];
        aesop;
      · refine' ⟨ _, _ ⟩;
        constructor;
        rotate_left;
        exact ⟨ y, hx_1_A ⟩;
        exact ⟨ x, hx_2_B ⟩;
        exact SimpleGraph.Walk.cons hxy.symm SimpleGraph.Walk.nil;
        simp [Finset.image];
        · by_cases h : y = x <;> simp_all
        · simp [ SimpleGraph.Walk.isPath_def ];
          exact hxy.ne.symm;
      · refine' ⟨ _, _ ⟩;
        constructor;
        rotate_left;
        exact ⟨ y, hx_1_A ⟩;
        exact ⟨ y, hx_2_B ⟩;
        exact SimpleGraph.Walk.nil;
        all_goals simp_all

/-
A path in the contracted graph that passes through the contracted vertex can be lifted to a path in the original graph.
-/
lemma SimpleGraph.exists_lifted_ABPath_through [Fintype V] (G : SimpleGraph V) (A B : Finset V) (x y : V) (hxy : G.Adj x y)
  (p' : (G.contractEdge' x y).ABPath (SimpleGraph.contractEdge_liftSet x y A) (SimpleGraph.contractEdge_liftSet x y B))
  (hp'_mem : SimpleGraph.contractEdge_vertex x y ∈ p'.walk.support) :
  ∃ p : G.ABPath A B,
    p.walk.support.toFinset.image (SimpleGraph.contractEdgeProj x y) ⊆ p'.walk.support.toFinset := by
      by_cases hu' : p'.u = SimpleGraph.contractEdge_vertex x y;
      · by_cases hv' : p'.v = SimpleGraph.contractEdge_vertex x y;
        · have h_lift_nil : SimpleGraph.contractEdge_vertex x y ∈ SimpleGraph.contractEdge_liftSet x y A ∧ SimpleGraph.contractEdge_vertex x y ∈ SimpleGraph.contractEdge_liftSet x y B := by
            grind;
          obtain ⟨ p, hp ⟩ := SimpleGraph.lift_path_nil_eq_vertex G A B x y hxy ( SimpleGraph.Walk.nil ) ( by simp ) h_lift_nil.1 h_lift_nil.2;
          exact ⟨ p, hp.trans ( by simp [ hp'_mem ] ) ⟩;
        · cases p';
          have := SimpleGraph.lift_path_start_eq_vertex G A B x y hxy;
          grind;
      · cases' p' with u' hv';
        rcases hv' with ⟨ v', hv' ⟩;
        by_cases hv' : v' = SimpleGraph.contractEdge_vertex x y;
        · convert SimpleGraph.lift_path_end_eq_vertex G A B x y hxy _ _ _ _ _ _;
          rotate_left;
          any_goals tauto;
          convert ‹ ( G.contractEdge' x y ).Walk _ _ ›;
          all_goals norm_num [ hv' ];
          · grind;
          · grind;
        · rename_i p hp;
          obtain ⟨ p, hp ⟩ := SimpleGraph.lift_path_through_contraction_internal G A B x y hxy u' v' p hp hp'_mem hu' hv' u'.2 ‹_›;
          obtain ⟨ v, p, hp₁, hp₂, hp₃, hp₄ ⟩ := hp;
          refine' ⟨ ⟨ _, _, _, _ ⟩, _ ⟩;
          exact ⟨ _, hp₁ ⟩;
          exact ⟨ v, hp₂ ⟩;
          exact p;
          all_goals simp_all [ Finset.subset_iff ];
          intro a ha; specialize hp₄ ha; unfold contractEdge_preimage at hp₄; aesop;

/-
Given a set of disjoint paths in the contracted graph, there exists a set of disjoint paths of the same size in the original graph.
-/
lemma SimpleGraph.exists_disjoint_paths_lift [Fintype V] (G : SimpleGraph V) (A B : Finset V) (x y : V)
    (hxy : G.Adj x y)
    (P' : ((G.contractEdge' x y).Joiner (contractEdge_liftSet x y A) (contractEdge_liftSet x y B))) :
  ∃ P : G.Joiner A B, P.1.card = P'.1.card := by
    have h_lift : ∀ (p' : (G.contractEdge' x y).ABPath (SimpleGraph.contractEdge_liftSet x y A) (SimpleGraph.contractEdge_liftSet x y B)), ∃ p : G.ABPath A B, p.walk.support.toFinset.image (SimpleGraph.contractEdgeProj x y) ⊆ p'.walk.support.toFinset := by
      intro p'
      by_cases hp'_avoid : SimpleGraph.contractEdge_vertex x y ∉ p'.walk.support;
      · exact ⟨ Classical.choose ( SimpleGraph.exists_lifted_ABPath_avoiding G A B x y p' hp'_avoid ), Classical.choose_spec ( SimpleGraph.exists_lifted_ABPath_avoiding G A B x y p' hp'_avoid ) |>.2.2.1 ⟩;
      · exact ⟨ Classical.choose ( SimpleGraph.exists_lifted_ABPath_through G A B x y hxy p' ( by aesop ) ), Classical.choose_spec ( SimpleGraph.exists_lifted_ABPath_through G A B x y hxy p' ( by aesop ) ) ⟩;
    choose f hf using h_lift;
    refine' ⟨⟨Finset.image f P'.1, _⟩, _ ⟩;
    · intro p hp p' hp' hpp';
      obtain ⟨ q, hq, rfl ⟩ := Finset.mem_image.mp hp; obtain ⟨ q', hq', rfl ⟩ := Finset.mem_image.mp hp';
      have := P'.2; simp_all [ Finset.disjoint_left ] ;
      intro v hv hv'; have := this q hq q' hq'; simp_all [ Finset.disjoint_left ] ;
      contrapose! this; simp_all [ Finset.subset_iff ] ;
      exact ⟨ by aesop_cat, _, hf q v hv, hf q' v hv' ⟩;
    · rw [ Finset.card_image_of_injOn ];
      intro p' hp' q' hq' h_eq; have := hf p'; have := hf q'; simp_all [ Finset.subset_iff ] ;
      contrapose! h_eq;
      have h_support_disjoint : Disjoint (p'.walk.support.toFinset) (q'.walk.support.toFinset) := by
        have := P'.2 p' hp' q' hq' h_eq; simp_all [ Finset.disjoint_left ] ;
      have h_support_disjoint_lift : Disjoint (f p').walk.support.toFinset (f q').walk.support.toFinset := by
        refine' Finset.disjoint_left.mpr _;
        intro a ha hb; have := hf p' a; have := hf q' a; simp_all [ Finset.disjoint_left ] ;
        grind;
      intro h; simp_all [ Finset.disjoint_left ] ;
      exact h_support_disjoint_lift ( h.symm ▸ ( f q' ).walk.start_mem_support ) ( ( f q' ).walk.start_mem_support )

/-
If min_sep(G/e) < k, then there exists a separator X in G such that |X|=k, x in X, and y in X.
-/
lemma SimpleGraph.Menger_case2_exists_X [Fintype V] (G : SimpleGraph V) (A B : Finset V) (x y : V) (hxy : x ≠ y)
  (k : ℕ)
  (h_min : G.mincut A B = k)
  (h_contract_min : (G.contractEdge' x y).mincut (SimpleGraph.contractEdge_liftSet x y A) (SimpleGraph.contractEdge_liftSet x y B) < k) :
  ∃ X : Finset V, G.Separates A B X ∧ X.card = k ∧ x ∈ X ∧ y ∈ X := by
    obtain ⟨Y, hY_sep, hY_card⟩ : ∃ Y : Finset (Quotient (SimpleGraph.contractEdgeSetoid x y)), (G.contractEdge' x y).Separates (SimpleGraph.contractEdge_liftSet x y A) (SimpleGraph.contractEdge_liftSet x y B) Y ∧ Y.card < k := by
      rw [ SimpleGraph.mincut ] at h_contract_min;
      contrapose! h_contract_min;
      simp ; grind
    obtain ⟨X, hX_sep, hX_card⟩ : ∃ X : Finset V, G.Separates A B X ∧ X.card = Y.card + 1 ∧ x ∈ X ∧ y ∈ X := by
      have := SimpleGraph.contractEdge_separator_contains_vertex G A B x y k h_min Y hY_sep hY_card hxy;
      have := SimpleGraph.contractEdge_separator_lift_separates G A B x y Y hY_sep;
      refine' ⟨ _, this, _, _, _ ⟩ <;> simp_all [ SimpleGraph.contractEdge_preimage ];
      · convert SimpleGraph.contractEdge_separator_lift_card x y hxy Y ‹_› using 1;
      · convert ‹contractEdge_vertex x y ∈ Y› using 1;
      · convert ‹contractEdge_vertex x y ∈ Y› using 1;
        exact Quotient.sound ( Or.inr ( by tauto ) );
    have hX_card_eq : X.card ≥ k := by
      have hX_card_eq : ∀ (S : Finset V), G.Separates A B S → S.card ≥ k := by
        rw [ ← h_min ];
        intro S hS
        simp [SimpleGraph.mincut]
        exact ⟨⟨S, hS⟩, le_of_eq rfl⟩
      exact hX_card_eq X hX_sep
    exact ⟨X, hX_sep, by linarith, hX_card.right.left, hX_card.right.right⟩

/-
If a path intersects X, there is a suffix starting in X that avoids X internally.
-/
lemma SimpleGraph.Walk.exists_suffix_path_avoiding_set {G : SimpleGraph V} {u v : V} (p : G.Walk u v)
    (X : Set V) (h : ∃ w ∈ p.support, w ∈ X) :
    ∃ (w : V) (q : G.Walk w v), w ∈ X ∧ q.IsPath ∧ q.support.toFinset ⊆ p.support.toFinset ∧ (∀ z ∈ q.support, z ∈ X → z = w) := by
    obtain ⟨w'', hw''⟩ : ∃ w'' : V, ∃ q : G.Walk v w'', w'' ∈ X ∧ q.IsPath ∧ q.support.toFinset ⊆ p.reverse.support.toFinset ∧ (∀ z ∈ q.support, z ∈ X → z = w'') := by
      have := SimpleGraph.Walk.exists_path_prefix_avoiding_set p.reverse X ?_ <;> aesop;
    obtain ⟨ q, hw'', hq_path, hq_support, hq_inter ⟩ := hw''; use w'', q.reverse; aesop;

/-
If X separates A and B in G and contains x and y, then any separator of X and B in G-xy is also a separator of A and B in G.
-/
lemma SimpleGraph.separator_in_G_of_separator_in_G_delete_edge_right (G : SimpleGraph V) (A B : Finset V) (x y : V) (X : Finset V) (S : Finset V)
  (hX : G.Separates A B X) (hx : x ∈ X) (hy : y ∈ X) (hxy : x ≠ y)
  (hS : (G.deleteEdge x y).Separates X B S) :
  G.Separates A B S := by
    have := @SimpleGraph.separator_in_G_of_separator_in_G_delete_edge;
    specialize this G B A;
    contrapose! this;
    refine' ⟨ x, y, ⟨X, _⟩, ⟨S, _⟩, hx, hy, hxy, _⟩;
    · -- Since separation is symmetric, if X separates A and B, then it also separates B and A.
      have h_symm : G.Separates A B X → G.Separates B A X := by
        exact fun h u hu v hv p => by obtain ⟨ x, hx₁, hx₂ ⟩ := h v hv u hu p.reverse; exact ⟨ x, by simpa using hx₁, hx₂ ⟩ ;
      exact h_symm hX;
    · intro u hu v hv p; specialize hS v hv u hu ( p.reverse ) ; aesop;
    · convert this using 1;
      simp [ SimpleGraph.Separates ];
      constructor <;> intro h u hu v hv p;
      · exact h v hv u hu p.reverse |> fun ⟨ x, hx₁, hx₂ ⟩ => ⟨ x, by simpa using hx₁, hx₂ ⟩;
      · convert h v hv u hu ( p.reverse ) using 1;
        simp [ SimpleGraph.Walk.support_reverse ]

/-
If X separates A and B in G and contains x and y, then the minimum separator size of A and X in G-xy is at least k.
-/
lemma SimpleGraph.min_sep_delete_ge_k_left (G : SimpleGraph V) (A B : Finset V) (x y : V) (X : Finset V)
  (k : ℕ)
  (h_min : G.mincut A B = k)
  (hX_sep : G.Separates A B X) (hx : x ∈ X) (hy : y ∈ X) (hxy : x ≠ y) :
  (G.deleteEdge x y).mincut A X ≥ k := by
    rw [ ← h_min ];
    apply Nat.find_mono
    intro n ⟨S, hS⟩
    have := separator_in_G_of_separator_in_G_delete_edge G A B x y ⟨X, hX_sep⟩ S hx hy hxy
    exact ⟨⟨_, this⟩, hS⟩

/-
If X separates A and B in G and contains x and y, then the minimum separator size of X and B in G-xy is at least k.
-/
lemma SimpleGraph.min_sep_delete_ge_k_right (G : SimpleGraph V) (A B : Finset V) (x y : V) (X : Finset V)
  (k : ℕ)
  (h_min : G.mincut A B = k)
  (hX_sep : G.Separates A B X) (hx : x ∈ X) (hy : y ∈ X) (hxy : x ≠ y) :
  (G.deleteEdge x y).mincut X B ≥ k := by
    -- Let $S$ be a separator of $X$ and $B$ in $G - xy$.
    have h.separator : ∀ S : Finset V, (G.deleteEdge x y).Separates X B S → G.Separates A B S := by
      exact fun S a ↦
        separator_in_G_of_separator_in_G_delete_edge_right G A B x y X S hX_sep hx hy hxy a;
    rw [ ← h_min ];
    apply Nat.find_mono
    intro n ⟨S, hS⟩
    have := h.separator S.1 S.2
    refine ⟨⟨_, this⟩, hS⟩

/-
If G' is a subgraph of G, then any set of disjoint paths in G' can be lifted to a set of disjoint paths in G with the same size.
-/
lemma SimpleGraph.lift_disjoint_paths_le (G G' : SimpleGraph V) (h : G' ≤ G) (A B : Finset V)
  (P : G'.Joiner A B) :
  ∃ Q : G.Joiner A B, Q.1.card = P.1.card := by
    obtain ⟨P, hP⟩ := P
    refine' ⟨⟨P.image _, _⟩, _ ⟩;
    refine' fun p => ⟨ p.u, p.v, _, _ ⟩;
    exact p.walk.map ( SimpleGraph.Hom.ofLE h );
    all_goals simp_all [ Finset.disjoint_left, disjointPaths ];
    exact p.isPath;
    · bound;
    · apply Finset.card_image_of_injOn;
      intro p hp q hq h_eq;
      -- Since the walks are equal, their supports must be the same. Therefore, p and q must be the same path.
      have h_support_eq : p.walk.support = q.walk.support := by
        replace h_eq := congr_arg ( fun f => f.walk.support ) h_eq ; aesop;
      contrapose hP
      intro hh
      specialize hh p hp q hq hP
      simp [← h_support_eq] at hh

/-
If there exists a separator X of size k containing x and y, then G has k disjoint A-B paths.
-/
lemma SimpleGraph.Menger_case2_imp_paths (G : SimpleGraph V) (A B : Finset V) (x y : V) (hxy : G.Adj x y)
  (k : ℕ)
  (h_min : G.mincut A B = k)
  (X : Finset V)
  (hX_sep : G.Separates A B X)
  (hX_card : X.card = k)
  (hx : x ∈ X)
  (hy : y ∈ X)
  (IH_delete : ∀ A' B', (G.deleteEdge x y).mincut A' B' ≤ (G.deleteEdge x y).maxflow A' B') :
  k ≤ G.maxflow A B := by
    -- Apply the induction hypothesis to the subgraph G-xy.
    have h_ind : (G.deleteEdge x y).maxflow A X ≥ k ∧ (G.deleteEdge x y).maxflow X B ≥ k := by
      have h_ind : (G.deleteEdge x y).mincut A X ≥ k ∧ (G.deleteEdge x y).mincut X B ≥ k := by
        exact ⟨ by simpa only [ ← h_min ] using SimpleGraph.min_sep_delete_ge_k_left G A B x y X k h_min hX_sep hx hy hxy.ne, by simpa only [ ← h_min ] using SimpleGraph.min_sep_delete_ge_k_right G A B x y X k h_min hX_sep hx hy hxy.ne ⟩;
      exact ⟨ le_trans h_ind.1 ( IH_delete _ _ ), le_trans h_ind.2 ( IH_delete _ _ ) ⟩;
    -- By the induction hypothesis, there exist sets of disjoint A-X paths and X-B paths in G-xy with size at least k.
    obtain ⟨⟨P_A', hP_A'_disj⟩, hP_A'_card⟩ : ∃ P_A' : (G.deleteEdge x y).Joiner A X, P_A'.1.card ≥ k := by
      grind [exists_maxflow (G.deleteEdge x y) A X]
    obtain ⟨⟨P_B', hP_B'_disj⟩, hP_B'_card⟩ : ∃ P_B' : (G.deleteEdge x y).Joiner X B, P_B'.1.card ≥ k := by
      grind [exists_maxflow (G.deleteEdge x y) X B]
    -- By the properties of the contraction, we can lift these paths to G.
    obtain ⟨⟨P_A, hP_A_disj⟩, hP_A_card⟩ : ∃ P_A : G.Joiner A X, P_A.1.card = k := by
      have := Finset.exists_subset_card_eq hP_A'_card;
      obtain ⟨ t, ht₁, ht₂ ⟩ := this;
      have h_lift_A : ∃ P_A : G.Joiner A X, P_A.1.card = t.card := by
        have := lift_disjoint_paths_le G (G.deleteEdge x y) ?_ A X ⟨t, ?_⟩
        · obtain ⟨⟨Q, hQ1⟩, hQ2⟩ := this
          exact ⟨⟨Q, hQ1⟩, hQ2⟩
        · intro u v; by_cases hu : u = x <;> by_cases hv : v = y <;> simp [ *, SimpleGraph.deleteEdge ] <;> tauto
        · exact fun p hp q hq hpq => hP_A'_disj p ( ht₁ hp ) q ( ht₁ hq ) hpq;
      simp_rw [← ht₂]
      exact h_lift_A
    obtain ⟨⟨P_B'', hP_B''_disj⟩, hP_B''_card⟩ : ∃ P_B'' : (G.deleteEdge x y).Joiner X B, P_B''.1.card = k := by
      obtain ⟨ P_B'', hP_B''_disj, hP_B''_card ⟩ := Finset.exists_subset_card_eq hP_B'_card;
      exact ⟨⟨P_B'', fun p hp q hq hpq => hP_B'_disj p ( hP_B''_disj hp ) q ( hP_B''_disj hq ) hpq⟩, hP_B''_card ⟩;
    have h_lift : ∃ P_B : G.Joiner X B, P_B.1.card = k := by
      have h_subgraph : (G.deleteEdge x y) ≤ G := by
        intro u v; simp [ SimpleGraph.deleteEdge ] ;
        tauto
      obtain ⟨⟨Q, hQ1⟩, hQ2⟩ := SimpleGraph.lift_disjoint_paths_le _ _ h_subgraph _ _ ⟨P_B'', hP_B''_disj⟩
      refine ⟨⟨Q, hQ1⟩, ?_⟩
      grind
    obtain ⟨P_B, hP_B_card⟩ := h_lift;
    obtain ⟨P, hP_card⟩ := SimpleGraph.disjoint_paths_join G A B X hX_sep k hX_card ⟨P_A, hP_A_disj⟩ hP_A_card
        P_B hP_B_card
    apply Nat.le_findGreatest
    · rw [← hP_card]
      exact Joiner.card_le P
    · refine ⟨P, hP_card⟩

/-
Inductive step for Menger's theorem.
-/
lemma SimpleGraph.Menger_inductive_step [Fintype V] (G : SimpleGraph V) (A B : Finset V) (x y : V)
    (hxy : G.Adj x y)
  (IH_contract : (G.contractEdge' x y).mincut (SimpleGraph.contractEdge_liftSet x y A) (SimpleGraph.contractEdge_liftSet x y B) ≤ (G.contractEdge' x y).maxflow (SimpleGraph.contractEdge_liftSet x y A) (SimpleGraph.contractEdge_liftSet x y B))
  (IH_delete : ∀ A' B', (G.deleteEdge x y).mincut A' B' ≤ (G.deleteEdge x y).maxflow A' B')
  : G.mincut A B ≤ G.maxflow A B := by
    by_cases h : ( G.contractEdge' x y ).mincut (contractEdge_liftSet x y A) (contractEdge_liftSet x y B) < G.mincut A B;
    · obtain ⟨X, hX_sep, hX_card, hx, hy⟩ : ∃ X : Finset V, G.Separates A B X ∧ X.card = G.mincut A B ∧ x ∈ X ∧ y ∈ X := by
        apply_rules [ SimpleGraph.Menger_case2_exists_X ];
        exact hxy.ne;
      have := SimpleGraph.Menger_case2_imp_paths G A B x y hxy ( G.mincut A B ) rfl X hX_sep hX_card hx hy IH_delete;
      aesop;
    · -- By the induction hypothesis on the contracted graph, there exists a set P' of disjoint paths in G/e with |P'| ≥ k.
      obtain ⟨P', hP'_card⟩ : ∃ P' : (G.contractEdge' x y).Joiner (contractEdge_liftSet x y A) (contractEdge_liftSet x y B), P'.1.card ≥ G.mincut A B := by
        obtain ⟨P, hP⟩ := SimpleGraph.exists_maxflow (G := G.contractEdge' x y) (A := contractEdge_liftSet x y A) (B := contractEdge_liftSet x y B)
        refine ⟨P, ?_⟩
        grind
      refine' le_trans hP'_card _;
      apply Nat.le_findGreatest $ (Joiner.card_le P').trans Finset.card_image_le
      exact SimpleGraph.exists_disjoint_paths_lift G A B x y hxy P';

/-
Auxiliary lemma for Menger's theorem: The theorem holds for any graph with n edges, proved by strong induction on n.
-/
theorem SimpleGraph.Menger_strong_aux (n : ℕ) :
  ∀ (V : Type u) [Fintype V] [DecidableEq V] (G : SimpleGraph V) [DecidableRel G.Adj] (A B : Finset V),
  G.edgeFinset.card = n → G.mincut A B ≤ G.maxflow A B := by
    induction' n using Nat.strong_induction_on with n ih;
    intros V _ _ G _ A B h_card
    by_cases h_empty : G.edgeFinset = ∅;
    · convert SimpleGraph.Menger_strong_base G A B _;
      aesop;
    · -- Let $e = xy$ be an edge in $G$.
      obtain ⟨x, y, hxy⟩ : ∃ x y : V, G.Adj x y := by
        simp +zetaDelta at *;
        contrapose! h_empty;
        ext x y; simp [h_empty];
      -- Apply the induction hypothesis to the contraction and deletion of $G$.
      have h_contract : (G.contractEdge' x y).edgeFinset.card < n := by
        exact h_card ▸ SimpleGraph.contractEdge_edge_card_lt G x y hxy
      have h_delete : (G.deleteEdge x y).edgeFinset.card < n := by
        apply SimpleGraph.deleteEdge_card_edges_lt G x y hxy |> lt_of_lt_of_le <| by aesop;
      apply SimpleGraph.Menger_inductive_step G A B x y hxy;
      · convert ih _ h_contract _ _ _ _ rfl;
      · exact fun A' B' ↦
        (fun {i₁ i₂} ↦ String.Pos.Raw.mk_le_mk.mp)
          (ih (G.deleteEdge x y).edgeFinset.card h_delete V (G.deleteEdge x y) A' B' rfl)

/-
Menger's theorem: The minimum number of vertices separating A from B in G is equal to the maximum number of disjoint A--B paths in G. (This is the strong direction: min separator <= max paths)
-/
theorem SimpleGraph.Menger_strong [Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj] (A B : Finset V) :
  G.mincut A B ≤ G.maxflow A B := by
    convert SimpleGraph.Menger_strong_aux ( G.edgeFinset.card ) V G A B rfl

/-
Menger's theorem: The minimum number of vertices separating A from B in G is equal to the maximum number of disjoint A--B paths in G.
-/
theorem SimpleGraph.Menger [Fintype V] (G : SimpleGraph V) [DecidableRel G.Adj] (A B : Finset V) :
  G.mincut A B = G.maxflow A B := by
    exact le_antisymm ( SimpleGraph.Menger_strong G A B ) ( SimpleGraph.Menger_weak G A B )

/-
Menger's theorem: there exist a separator set `S` between `A` and `B` and a set
`P`of disjoint A-B paths such that `S` is formed of exactly one vertez vrom each
path in `P`.

This version would actually be true without the `[Fintype S]` assumption.
-/
theorem SimpleGraph.Menger' [Fintype V] : ∃ P : G.Joiner A B, ∃ S : G.Separator A B, ∃ φ : P.1 ≃ S.1,
    ∀ p : P.1, (φ p).1 ∈ p.1.walk.support := by
  obtain ⟨P, hP⟩ := @exists_maxflow _ G A B ; use P
  obtain ⟨S, hS⟩ := @exists_mincut _ G A B ; use S
  have key (p : P.1) : ∃ x : S.1, x.1 ∈ p.1.walk.support := by
    obtain ⟨x, h1, h2⟩ := S.2 p.1.u p.1.u.2 p.1.v p.1.v.2 p.1.walk
    refine ⟨⟨x, h2⟩, h1⟩
  choose f hf1 using key
  have hf : f.Injective := by
    intro p q hpq
    by_contra h
    have h1 := P.2 p p.2 q q.2 (by simpa)
    simp at h1
    exact h1 (hf1 p) (hpq ▸ hf1 q)
  refine ⟨.ofBijective f (Fintype.bijective_iff_injective_and_card _ |>.mpr ⟨hf, ?_⟩), hf1⟩
  simp [hP, hS, Menger]

#print axioms SimpleGraph.Menger
-- #lint
